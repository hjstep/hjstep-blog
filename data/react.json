{"posts":[{"attributes":{"title":"동시성 렌더링","summary":"리액트 18 동시성 렌더링에 대해서","tag":["REACT"],"imgSrc":"static/img/react.jpg"},"htmlBody":"<h2>동시성 렌더링을 다룰 수 있는 훅</h2>\n<p>지연된 렌더링은 중단가능, 사용자의 인터렉션을 차단하지않는다</p>\n<ul>\n<li>\n<p><strong>useTransition</strong></p>\n<ul>\n<li>무거운 연산 UI 조각을 렌더링 일으키는 상태 업데이트에 대해 낮은 우선순위를 부여하여 상태 변경을 지연시켜서 렌더링을 지연시킨다.</li>\n<li>startTransition에 상태를 업데이트 하는 함수를 인수로 받는다</li>\n<li>비동기로 처리하므로 startTransition에 비동기함수는 넣을 수 없다. (실행시점이 불확실해지므로 메커니즘과 맞지않음)</li>\n</ul>\n<ol>\n<li>비동기 렌더링 (지연 렌더링) 처리</li>\n<li>로딩 상태 관리</li>\n<li>낮은 렌더링 우선순위\n<code>const [isPending, startTransition] = useTransition();</code></li>\n</ol>\n</li>\n<li>\n<p><strong>useDeferredValue</strong></p>\n<ul>\n<li>useTransition과 다르게 상태를 업데이트하는 함수가 아니라 상태 값자체를 인수로 받는다.</li>\n<li>디바운스와 비슷, 그러나 디바운스와 달리 고정된 지연시간 없이 첫번째 렌더링이 완료된 후에 지연된 렌더링을 수행한다.</li>\n<li>useTransition와 사용하는 방식에만 차이가있을뿐, 지연된 렌더링을 한다는점에서 동일하다.\n<code>const deferredValue = useDeferredValue(value)</code></li>\n</ul>\n</li>\n</ul>\n<h2>동시성 이슈 - 테어링 현상 발생</h2>\n<p>같은 상태를 바라보는 UI 조각이 여러개인 경우,  리액트 18의 useTransition, useDeferredValue를 사용한 UI 조각은 상태 변경을 지연시킨다. 이때 이 훅들을 사용하지않은 UI조각은 이전 상태로 렌더링이 되는데, 훅들을 사용한 UI 조각은 무거운 연산이 끝나고 상태변경 및 렌더링이 되므로\n같은 상태를 바라보아도 “화면이 찢어지는(테어링) 현상”이 발생한다.따라서 다른 값을 렌더링하게 된다.</p>\n<blockquote>\n<p>이를 해결하려면 useSyncExternalStore로 외부 상태를 구독해서 상태 동기화를 시켜야한다.</p>\n</blockquote>\n<ul>\n<li>동시성 이슈는 보통 외부 상태에서 발생.\n<ul>\n<li>보통 리액트에서 관리하는 상태(useState, useReducer)인 경우 발생할 확률이 적지만, 리액트에서 관리하지않는 외부상태인 경우 발생하므로 동시성 처리를 해야한다.</li>\n</ul>\n</li>\n</ul>\n<h2>useSyncExternalStore 훅</h2>\n<p>외부 상태를 구독해서 상태 동기화를 시켜준다.</p>\n<pre><code class=\"language-javascript\">useSyncExternalStore(\n    subscribe: (callback) =&gt; Unsubscribe,\n    getSnapshot: () =&gt; state\n) =&gt; State\n</code></pre>\n"},{"attributes":{"title":"파이버 아키텍쳐","summary":"리액트 렌더링 아키텍쳐인 파이버에 대해서","tag":["REACT"],"imgSrc":"static/img/react.jpg"},"htmlBody":"<p>React 16에 등장한 가상 DOM을 이용하여 렌더링 과정을 최적화하기 위한 아키텍처다.</p>\n<ul>\n<li>비동기적으로 렌더링 작업 처리 가능\n<ul>\n<li>렌더링 작업을 일시중단/다시 시작/폐기 가능</li>\n</ul>\n</li>\n<li>Incremental Rendering(단계적 렌더링)\n<ul>\n<li>렌더링 작업을 작은 단위로 쪼개어 분할할 수 있다.</li>\n</ul>\n</li>\n<li>우선순위\n<ul>\n<li>렌더링 작업에 우선순위를 매길 수 있다.</li>\n</ul>\n</li>\n</ul>\n<h2>파이버 작업</h2>\n<p>트리 업데이트 과정을 파이버 단위로 나눠서 수행한다.</p>\n<ol>\n<li>변경 감지 : 컴포넌트의 props나 state 변경 감지</li>\n<li>WorkInProgress 트리 생성 : current 트리를 기반으로 생성한다 (파이버노드 재사용)</li>\n<li>WorkInProgress 트리에 업데이트 적용 : 업데이트 사항이 WorkInProgress 트리의 각 파이버노드에 적용됨</li>\n<li>Diffing 알고리즘 적용 : 실제 DOM에 필요한 변경사항을 최소화하기 위해 Diffing 알고리즘을 적용하여 current와 workInProgress를 비교한다.</li>\n<li>커밋 단계 : 더블 버퍼링 메커니즘으로, current 트리를 workInProgress 트리로 교체한다. 그리고 이 트리가 UI에 최종적으로 렌더링되어 반영된다.</li>\n</ol>\n<h2>파이버 (FiberNode 생성자함수에 의해 생성된 인스턴스)</h2>\n<ul>\n<li>하나의 element 마다 생성됨</li>\n<li>파이버간의 관계는 child, sibling, return, index 프로퍼티로 표현</li>\n<li>alternate : 반대편 트리 파이버를 가리킴</li>\n</ul>\n<h2>파이버 트리 2개</h2>\n<ol>\n<li>current 트리 : 현재 화면에 렌더링된 UI 트리</li>\n<li>workInProgress 트리 : 업데이트가 진행중인 상태를 나타내는 트리</li>\n</ol>\n<h1>파이버 아키텍처 기반의 리액트 렌더링 프로세스</h1>\n<h3><strong>렌더 단계</strong></h3>\n<ol>\n<li><strong>workInProgress 트리 생성</strong>:\n<ul>\n<li>렌더 단계가 시작되면, <strong><code>current</code></strong> 트리의 복사본으로 <strong><code>workInProgress</code></strong> 트리가 생성된다.</li>\n</ul>\n</li>\n<li><strong>workInProgress 트리 탐색</strong>:\n<ul>\n<li>리액트는 <strong><code>workInProgress</code></strong> 트리를 루트부터 업데이트가 필요하다고 지정돼있는 모든 컴포넌트들을 탐색한다. 변경이 필요한 컴포넌트를 발견하면(변경 감지) 클래스형 컴포넌트이면 <strong><code>render</code></strong> 메서드 또는 함수형 컴포넌트이면 <code>**함수 자체**</code>가 호출되어 반환된 결과(render() 또는 return)가 workInProgress 트리의 해당 파이버 노드로 저장된다. 이런식으로 탐색하여 모든 변경사항을 workInProgress 트리에 반영한다.</li>\n</ul>\n</li>\n<li><strong>리액트의</strong> <strong>재조정 과정(Reconciliation)</strong>: DOM 반영이 필요한 컴포넌트를 체크하는 단계\n<ul>\n<li>효율적으로 최소한의 DOM 업데이트를 하기위해 재조정 과정을 거친다.\n<strong><code>workInProgress</code></strong> 트리와 <strong><code>current</code></strong> 트리 사이에서 type, key, props를 기준으로 변경 사항을 식별한다.(type, key가 변경되면 새로운 노드를 생성하고, 만약 type, key가 동일하다면 props 변경을 기준으로 식별)\n<ul>\n<li><strong>Fiber 노드에 효과 태그로 업데이트 표시</strong>:\n각 <strong><code>Fiber</code></strong> 노드를 검사한다.  변경이 필요한 파이버 노드에 효과 태그를 할당한다(추가, 삭제, 업데이트에 따라 효과태그가 다름)</li>\n<li><strong>업데이트 큐</strong>:\n변경이 감지된 컴포넌트의 <strong><code>Fiber</code></strong> 노드에 업데이트 큐를 생성하거나 업데이트한다. 이 업데이트 큐에는 상태 변경, props 변경 등의 정보가 포함될 수 있다.</li>\n<li><strong>효과 리스트(Effect List)</strong>:\n효과 태그가 할당된(변경 사항이 체크된) <strong><code>Fiber</code></strong> 노드는 효과 리스트(Effect List)에 추가됩니다. 이 효과 리스트는 커밋 단계에서 실제 DOM에 적용할 변경 사항들의 목록을 나타냅니다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>렌더 단계 완성</strong>:\n<ul>\n<li><code>**workInProgress</code>** 트리에 모든 변경사항이 적용되고 필요한 업데이트가 계산되면 렌더 단계가 완성되며, <strong><code>workInProgress</code></strong> 트리는 커밋 단계로 넘어갈 준비가 된다.</li>\n</ul>\n</li>\n<li><strong>중단 및 재개</strong>: 리액트 파이버는 렌더단계를 비동기로 작동하게 할 수 있음(이게 스택조정자는 동기였음)\n<ul>\n<li>리액트는 렌더단계를 비동기로 작동해 특정 렌더링의 우선순위를 낮추거나, 중단, 재시작, 폐기할 수 있다.\n<ul>\n<li>이를 통해 브라우저의 동기 작업을 차단하지 않고 백그라운드에서 새로운 리액트 트리를 준비할 수도있으므로 사용자는 더욱 매끄러운 UX를 누릴수있다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3><strong>커밋 단계</strong></h3>\n<ol>\n<li><strong>실제 DOM에 변경 사항 렌더링</strong>:\n<ul>\n<li>효과 리스트를 순회하며, 각 <strong><code>Fiber</code></strong> 노드에 표시된 변경 사항을 실제 DOM에 반영한다.</li>\n</ul>\n</li>\n<li><strong>current 트리로 교체</strong>:\n<ul>\n<li>DOM 업데이트가 완료되면, <strong><code>current</code></strong> 트리는 <strong><code>workInProgress</code></strong> 트리로 교체된다.\n(모든 DOM 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트함)</li>\n</ul>\n</li>\n<li><strong>라이프사이클 메소드 및 후크 호출</strong>:\n<ul>\n<li>클래스형 컴포넌트의 경우, 라이프사이클 메서드(<strong><code>componentDidMount</code></strong>, <strong><code>componentDidUpdate</code></strong>)를 호출한다. 함수형 컴포넌트의 경우, **<code>useLayoutEffect</code>**훅을 호출한다.</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는것은 아니다.\n렌더단계에서 변경사항을 계산했는데 아무런 변경사항이 감지되지 않는다면 커밋단계는 생략될 수 있다.</p>\n</blockquote>\n"},{"attributes":{"title":"서버 컴포넌트","summary":"리액트 18에 추가된 서버 컴포넌트에 대해서","tag":["REACT"],"imgSrc":"static/img/react.jpg"},"htmlBody":"<h3>서버 컴포넌트, 클라이언트 컴포넌트, 공용 컴포넌트</h3>\n<ul>\n<li><strong>서버 컴포넌트</strong>\n<ul>\n<li>요청이 오면 한번만 서버에서 실행된다. 렌더링되면 끝이기에 상태를 가질수도없고 렌더링 생명주기를 사용할 수 없다.</li>\n<li>컴포넌트 자체가 async한 것이 가능, 서버에만 있는 데이터 async/await으로 접근가능</li>\n</ul>\n</li>\n<li><strong>클라이언트 컴포넌트</strong>\n<ul>\n<li>브라우저 환경에서만 실행됨. 서버 컴포넌트를 import할 수 없다</li>\n<li>자식으로 서버 컴포넌트를 갖는 구조는 가능하다</li>\n</ul>\n</li>\n<li><strong>공용 컴포넌트</strong>\n<ul>\n<li>서버, 클라이언트 모두 사용가능.</li>\n</ul>\n</li>\n</ul>\n<h3>판단 기준</h3>\n<p>리액트는 모든 컴포넌트를 공용 컴포넌트로 판단한다.\n클라이언트 컴포넌트라는 것을 명시적으로 선언('use client')된 클라이언트 컴포넌트를 제외한 모든 컴포넌트는 서버에서 실행가능한 컴포넌트라고 인식한다.</p>\n<h3>서버 컴포넌트 렌더링</h3>\n<ul>\n<li>서버 컴포넌트는 서버에서 렌더링한 결과물이 HTML이 아니라 JSON 형태이다.</li>\n<li>클라이언트에게 JSON 형태 결과물을 보낸다.\n<ul>\n<li>이 JSON 결과물을 받아서 다시 역직렬화한 다음, JSON을 파싱하여 파싱한 결과물을 바탕으로 리액트 컴포넌트 트리를 재구성해나간다.(파이버노드 객체)</li>\n<li>컴포넌트 트리를 완성하면 이 트리를 렌더링해 브라우저의 DOM에 커밋한다</li>\n</ul>\n</li>\n</ul>\n"}]}