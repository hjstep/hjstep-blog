{"posts":[{"attributes":{"title":"[시리즈] 리액트 원리 파헤치기 03 - VDOM과 reconciler","summary":"리액트 파헤치기 시리즈 03 - VDOM과 reconciler","tag":["리액트 파헤치기 시리즈","REACT"],"idx":7},"htmlBody":"<p>virtual DOM이라고 하는 VDOM과 reconciler에 대해 알아보자.</p>\n<h2>VDOM은 리액트의 렌더링 컨셉이다.</h2>\n<p>UI 정보를 가진 가상 DOM과 실제 DOM을 비교하여(재조정) 업데이트된 부분만 일괄로 브라우저에 반영한다라는 컨셉이다.<br>\n왜 가상에서 하냐면 실제 DOM을 조작하면서 paint하면 가상으로 하는것보다 훨씬 더 비용이 들기 때문이다.<br>\n따라서 리액트는 가상 DOM과 렌더링 과정 최적화(재조정 reconciliation)를 통해 렌더링을 지원하는 라이브러리이다.</p>\n<p>그렇다면 리액트의 렌더링 방식은 어떤 설계방식(아키텍쳐)로 이루어져있을까?<br>\n그건 바로 리액트 파이버이다.</p>\n<h2>VDOM의 구현</h2>\n<p>리액트 파이버아키텍쳐에서 VDOM은 FiberNode 생성자 함수로 생성한 객체들의 집합으로 이루어진 트리 구조이다.<br>\n이 파이버 트리는 애플리케이션의 구조와 상태를 나타내며 current트리와 workInProgress 트리 2개가 존재한다.</p>\n<ol>\n<li><strong>current 트리</strong></li>\n</ol>\n<ul>\n<li>현재 UI 렌더링 정보가 담긴 파이버 트리</li>\n</ul>\n<ol start=\"2\">\n<li><strong>workInProgress 트리</strong></li>\n</ol>\n<ul>\n<li>작업중인 상태를 나타내는 트리</li>\n</ul>\n<p>왜 2개가 존재하냐면 더블 버퍼링 구조로 설계되어 있기때문에 원본 트리와 작업중 트리를 가지고 있으며,<br>\n렌더링 순서를 유연하게 조작하기 위해서는 원본이 필요하기 때문이다.\n즉, 업데이트가 발생하면 current tree를 복제하여 workInProgress tree가 생성되고<br>\n이 workInProgress tree에 변경사항을 업데이트하고 재조정 과정을 거쳐 render phase가 끝나고 commit phase에서 current tree로 교체된다.</p>\n<h2>reconciler</h2>\n<p>reconciler는 업데이트를 감지하여 workInProgress 트리를 만들고  current트리와 workInProgress 트리를 비교하여 실제 DOM에 적용할 업데이트사항을 결정하는 역할을 한다.</p>\n<h2>라이프사이클</h2>\n<p>리액트에서 라이프사이클 단계는 render phase단계와 commit phase단계로 이루어져있다.</p>\n<ol>\n<li><strong>render phase</strong></li>\n</ol>\n<ul>\n<li>VDOM을 재조정(reconciliation)하는 단계이다.</li>\n<li>이 과정은 비동기로 실행될 수 있다.(이전 stack아키텍처는 이부분이 동기적으로 발생되었었음)</li>\n</ul>\n<ol start=\"2\">\n<li><strong>commit phase</strong></li>\n</ol>\n<ul>\n<li>재조정한 VDOM을 실제 DOM에 일괄 반영하고 라이프사이클 메소드 또는 훅을 실행하는 단계이다.</li>\n<li>이 과정은 동기적으로 실행된다.</li>\n</ul>\n<h2>마치며</h2>\n<p>이번에는 VDOM과 reconciler가 무엇인지에 대해 간략히 알아보았다.<br>\n복잡하게 생각할 필요없이 결국 리액트는 VDOM과 reconciler라는 컨셉을 통해 렌더링 과정을 최적화하는 라이브러리라는 것을 기억하자.<br>\n다음은 useState를 코드 레벨에서 까보면서 reconciler가 어떤 역할을 하는지 자세히 알아보자.</p>\n"},{"attributes":{"title":"[시리즈] 리액트 원리 파헤치기 02 - react element","summary":"리액트 파헤치기 시리즈 02 - react element","tag":["리액트 파헤치기 시리즈","REACT"],"idx":6},"htmlBody":"<p>fiber node 객체에 대해 살펴보기전에 react element가 무엇인지 정확히 알고 넘어갈 필요가 있다.<br>\nreact element가 무엇인지에 대해 살펴보자</p>\n<h2>react element란?</h2>\n<p>react element는 컴포넌트 관련 정보를 갖고 있는 객체이다. type, key, props, ref 등의 프로퍼티를 소유하고 있다.<br>\nreact element 종류로는 DOM elements와 Component elements가 있다.</p>\n<p>우리가 리액트 컴포넌트를 작성할때 JSX문법으로 작성하면 그것을 트랜스파일링하여 react element 형태를 리턴받게 된다.<br>\n이 과정을 좀더 자세하게 설명하자면 다음과 같다.</p>\n<pre><code class=\"language-javascript\">컴포넌트를 호출 -&gt; 리턴한 DOM elements (JSX 문법) -&gt; 트랜스파일링 -&gt; react.createElement()를 호출 -&gt; react element를 리턴받음\n</code></pre>\n<p>컴포넌트를 호출했을때 Component elements를 리턴받으면 DOM elements를 리턴할때까지 계속해서 순회하여 호출하게 된다. 결국 DOM elements로 구성되어있는 element tree가 완성된다.</p>\n<h2>react element의 종류</h2>\n<p>종류는 DOM elements, Component elements 2가지 종류가 있다.<br>\n<code>(type: string | ReactClass, props: object)</code><br>\n이때 type이 string이면 DOM elements이며, ReactClass이면 Component elements이다.</p>\n<ol>\n<li>DOM elements</li>\n</ol>\n<ul>\n<li>type: string</li>\n<li>props: html태그의 attribute</li>\n</ul>\n<pre><code class=\"language-javascript\">&lt;button className=&quot;btn-red&quot;&gt;\n    confirm\n&lt;/button&gt;\n\n// 트랜스파일링 결과\n{\n  type: 'button',\n    props: {\n      className: 'btn-red',\n      children: 'confirm'\n    }\n}\n</code></pre>\n<ol start=\"2\">\n<li>Component elements</li>\n</ol>\n<ul>\n<li>type: ReactClass</li>\n<li>props: DOM 렌더링에 필요한 정보들</li>\n</ul>\n<pre><code class=\"language-javascript\">&lt;Button color=&quot;red&quot;&gt;confirm&lt;/Button&gt;\n\n// 트랜스파일링 결과\n{\n    type: Button,\n    props: {\n        color: 'red',\n        children: 'confirm'\n    }\n}\n</code></pre>\n<p>Component elements는 DOM elements를 캡슐화한 것이다.<br>\n해당 컴포넌트를 호출하면 DOM elements를 결국 return 하게 된다.</p>\n<pre><code class=\"language-javascript\">&lt;Button color=&quot;red&quot;&gt;confirm&lt;/Button&gt;\n\nfunction Button(props) {\n  return (\n\t&lt;button className={props.color}&gt;\n\t\tconfirm\n\t&lt;/button&gt;\n  )\n}\n</code></pre>\n<h2>정리</h2>\n<p>즉 Component elements로 개발자가 직접 DOM 트리에 전달할 정보를 정의할 수 있고<br>\n각각의 elements들이 elements tree 구조로 이루어 DOM 트리에 전달할 정보를 가지고 있게 되는 자바스크립트 객체인 것이다.</p>\n<h2>마치며</h2>\n<p>사실 react element는 fiber node로 확장되어 VDOM에 반영되게 된다.<br>\n이는 앞으로 자세하게 알아볼 것이니 react element가 무엇인지에 대해서만 기억하자</p>\n"},{"attributes":{"title":"[시리즈] 리액트 원리 파헤치기 01 - Intro","summary":"리액트 파헤치기 시리즈 01 - 사전지식","tag":["리액트 파헤치기 시리즈","REACT"],"idx":5},"htmlBody":"<p>리액트 원리를 깊게 파악하고 싶어서 <strong>&quot;리액트 원리 파헤치기&quot;</strong> 시리즈를 작성하려고 한다.<br>\n이 시리즈는 리액트 아키텍쳐와 리액트 패키지가 어떻게 구성되어있는지, 동작 원리는 무엇인지 파헤쳐보는 시리즈이다.<br>\n본격적으로 시리즈에 들어가기 앞서 리액트 원리를 이해하는데 필요한 배경과 사전지식에 대해 알아보자</p>\n<h2>배경</h2>\n<p>리액트 16버전 이전에는 <strong>Stack Reconciler 아키텍쳐</strong>로 구성되어 있었다.<br>\nstack 자료구조 형태이기 때문에 LIFO 형태로 마지막에 들어간 task를 먼저 렌더링해야만 하는 고정적인 순서가 있었고, 동기적으로 컴포넌트 트리를 업데이트해야만 했다.<br>\n이는 업데이트가 크게 발생하면 브라우저 메인 스레드를 블로킹하므로 마치 UI가 멈춘것처럼 느껴지게 하는 좋지않은 UX를 안겨주었고,\n렌더링 순서도 마음대로 변경하거나 일시중단할 수 없었다.<br>\n특히 복잡한 애플리케이션에서 렌더링 성능에 악영향을 미쳤다.<br>\n따라서 이러한 문제를 해결하기 위해 Fiber 아키텍쳐가 도입되었다.</p>\n<h2>Fiber 아키텍쳐란?</h2>\n<p>리액트 16에 등장한 렌더링 아키텍쳐로, Stack 아키텍쳐의 문제점을 해결하기 위해 등장했다.(물론 본격적으로 파이버 아키텍쳐가 사용되기 시작한 버전은 리액트 18버전 부터(useTransition, usedeferredvalue))<br>\n메인 스레드가 블로킹되는 것을 방지하고 비동기적으로 업데이트가 발생하므로 렌더링 task를 일시중단하거나 재개할 수 있으며, 또한 우선순위를 부여하여 우선순위 기반의 스케줄링을 할 수 있다.<br>\n메인 스레드가 블로킹되지 않기 때문에 이전의 Stack 아키텍쳐보다 UX가 향상되었다.</p>\n<h2>알아두어야할 사전지식</h2>\n<p>여기까지 리액트 렌더링 아키텍쳐의 배경과 개념에 대해 간략하게 알아보았다.<br>\n이제 알아두어야할 사전지식들에 대해서 설명하겠다.<br>\n설명할 사전지식들의 목차는 다음과 같다.</p>\n<pre><code class=\"language-javascript\">1. 리액트에서의 렌더링 개념\n2. react element란?\n3. fiber 노드란?\n</code></pre>\n<p>각각에 대해 알아보자</p>\n<h3>1. 리액트에서의 렌더링 개념</h3>\n<p>리액트에서 렌더링이라고 부르는 개념과 우리가 흔히 알고있는 렌더링 개념은 조금 차이가 있다.<br>\n리액트에서의 렌더링은 컴포넌트를 호출하고 VDOM 재조정 작업까지를 렌더링이라고 하며, 브라우저에 반영되는 것은 이후 commit phase에서 진행한다.<br>\n정리하자면 우리가 알고있는 렌더링은 브라우저에 반영까지인데, 리액트에서 렌더링은 렌더링 재조정자가 진행하는 과정까지를 말한다. 헷갈리지않게 숙지하자.</p>\n<h3>2. react element란?</h3>\n<p>컴포넌트가 리턴한 JSX를 트랜스파일링하여 결국 <code>react.createElement()</code>를 호출하게된다.(요즘은 jsxRuntime) 이때 리턴한 내용을 <strong>react element</strong>라고 한다.<br>\nreact element란 DOM에 적용될 내용이 담긴(컴포넌트 정보들) 객체인데 type, key, props, ref 프로퍼티로 구성되어있다.</p>\n<h3>3. fiber 노드란?</h3>\n<p>react element를 확장한 것으로 VDOM의 노드 객체를 말한다.<br>\nreact element에서 state, 라이프사이클, hook이 추가된 노드이다.(VDOM은 DOM에 반영될 정보가 담겨있다)</p>\n<h2>마치며</h2>\n<p>여기까지 리액트 원리 파헤치기 시리즈에 들어가기 앞서 사전지식들에 대해 작성해보았다.<br>\n다음은 react element가 무엇인지 파헤쳐보자.</p>\n"},{"attributes":{"title":"서버 컴포넌트","summary":"리액트 18에 추가된 서버 컴포넌트에 대해서","tag":["REACT"],"imgSrc":"static/img/react.jpg","idx":3},"htmlBody":"<h3>서버 컴포넌트, 클라이언트 컴포넌트, 공용 컴포넌트</h3>\n<ul>\n<li><strong>서버 컴포넌트</strong>\n<ul>\n<li>요청이 오면 한번만 서버에서 실행된다. 렌더링되면 끝이기에 상태를 가질수도없고 렌더링 생명주기를 사용할 수 없다.</li>\n<li>컴포넌트 자체가 async한 것이 가능, 서버에만 있는 데이터 async/await으로 접근가능</li>\n</ul>\n</li>\n<li><strong>클라이언트 컴포넌트</strong>\n<ul>\n<li>브라우저 환경에서만 실행됨. 서버 컴포넌트를 import할 수 없다</li>\n<li>자식으로 서버 컴포넌트를 갖는 구조는 가능하다</li>\n</ul>\n</li>\n<li><strong>공용 컴포넌트</strong>\n<ul>\n<li>서버, 클라이언트 모두 사용가능.</li>\n</ul>\n</li>\n</ul>\n<h3>판단 기준</h3>\n<p>리액트는 모든 컴포넌트를 공용 컴포넌트로 판단한다.\n클라이언트 컴포넌트라는 것을 명시적으로 선언('use client')된 클라이언트 컴포넌트를 제외한 모든 컴포넌트는 서버에서 실행가능한 컴포넌트라고 인식한다.</p>\n<h3>서버 컴포넌트 렌더링</h3>\n<ul>\n<li>서버 컴포넌트는 서버에서 렌더링한 결과물이 HTML이 아니라 JSON 형태이다.</li>\n<li>클라이언트에게 JSON 형태 결과물을 보낸다.\n<ul>\n<li>이 JSON 결과물을 받아서 다시 역직렬화한 다음, JSON을 파싱하여 파싱한 결과물을 바탕으로 리액트 컴포넌트 트리를 재구성해나간다.(파이버노드 객체)</li>\n<li>컴포넌트 트리를 완성하면 이 트리를 렌더링해 브라우저의 DOM에 커밋한다</li>\n</ul>\n</li>\n</ul>\n"},{"attributes":{"title":"동시성 렌더링","summary":"리액트 18 동시성 렌더링에 대해서","tag":["REACT"],"imgSrc":"static/img/react.jpg","idx":2},"htmlBody":"<h2>동시성 렌더링을 다룰 수 있는 훅</h2>\n<p>지연된 렌더링은 중단가능, 사용자의 인터렉션을 차단하지않는다</p>\n<ul>\n<li>\n<p><strong>useTransition</strong></p>\n<ul>\n<li>무거운 연산 UI 조각을 렌더링 일으키는 상태 업데이트에 대해 낮은 우선순위를 부여하여 상태 변경을 지연시켜서 렌더링을 지연시킨다.</li>\n<li>startTransition에 상태를 업데이트 하는 함수를 인수로 받는다</li>\n<li>비동기로 처리하므로 startTransition에 비동기함수는 넣을 수 없다. (실행시점이 불확실해지므로 메커니즘과 맞지않음)</li>\n</ul>\n<ol>\n<li>비동기 렌더링 (지연 렌더링) 처리</li>\n<li>로딩 상태 관리</li>\n<li>낮은 렌더링 우선순위\n<code>const [isPending, startTransition] = useTransition();</code></li>\n</ol>\n</li>\n<li>\n<p><strong>useDeferredValue</strong></p>\n<ul>\n<li>useTransition과 다르게 상태를 업데이트하는 함수가 아니라 상태 값자체를 인수로 받는다.</li>\n<li>디바운스와 비슷, 그러나 디바운스와 달리 고정된 지연시간 없이 첫번째 렌더링이 완료된 후에 지연된 렌더링을 수행한다.</li>\n<li>useTransition와 사용하는 방식에만 차이가있을뿐, 지연된 렌더링을 한다는점에서 동일하다.\n<code>const deferredValue = useDeferredValue(value)</code></li>\n</ul>\n</li>\n</ul>\n<h2>동시성 이슈 - 테어링 현상 발생</h2>\n<p>같은 상태를 바라보는 UI 조각이 여러개인 경우,  리액트 18의 useTransition, useDeferredValue를 사용한 UI 조각은 상태 변경을 지연시킨다. 이때 이 훅들을 사용하지않은 UI조각은 이전 상태로 렌더링이 되는데, 훅들을 사용한 UI 조각은 무거운 연산이 끝나고 상태변경 및 렌더링이 되므로\n같은 상태를 바라보아도 “화면이 찢어지는(테어링) 현상”이 발생한다.따라서 다른 값을 렌더링하게 된다.</p>\n<blockquote>\n<p>이를 해결하려면 useSyncExternalStore로 외부 상태를 구독해서 상태 동기화를 시켜야한다.</p>\n</blockquote>\n<ul>\n<li>동시성 이슈는 보통 외부 상태에서 발생.\n<ul>\n<li>보통 리액트에서 관리하는 상태(useState, useReducer)인 경우 발생할 확률이 적지만, 리액트에서 관리하지않는 외부상태인 경우 발생하므로 동시성 처리를 해야한다.</li>\n</ul>\n</li>\n</ul>\n<h2>useSyncExternalStore 훅</h2>\n<p>외부 상태를 구독해서 상태 동기화를 시켜준다.</p>\n<pre><code class=\"language-javascript\">useSyncExternalStore(\n    subscribe: (callback) =&gt; Unsubscribe,\n    getSnapshot: () =&gt; state\n) =&gt; State\n</code></pre>\n"},{"attributes":{"title":"파이버 아키텍쳐","summary":"리액트 렌더링 아키텍쳐인 파이버에 대해서","tag":["REACT"],"imgSrc":"static/img/react.jpg","idx":1},"htmlBody":"<p>React 16에 등장한 가상 DOM을 이용하여 렌더링 과정을 최적화하기 위한 아키텍처다.</p>\n<ul>\n<li>비동기적으로 렌더링 작업 처리 가능\n<ul>\n<li>렌더링 작업을 일시중단/다시 시작/폐기 가능</li>\n</ul>\n</li>\n<li>Incremental Rendering(단계적 렌더링)\n<ul>\n<li>렌더링 작업을 작은 단위로 쪼개어 분할할 수 있다.</li>\n</ul>\n</li>\n<li>우선순위\n<ul>\n<li>렌더링 작업에 우선순위를 매길 수 있다.</li>\n</ul>\n</li>\n</ul>\n<h2>파이버 작업</h2>\n<p>트리 업데이트 과정을 파이버 단위로 나눠서 수행한다.</p>\n<ol>\n<li>변경 감지 : 컴포넌트의 props나 state 변경 감지</li>\n<li>WorkInProgress 트리 생성 : current 트리를 기반으로 생성한다 (파이버노드 재사용)</li>\n<li>WorkInProgress 트리에 업데이트 적용 : 업데이트 사항이 WorkInProgress 트리의 각 파이버노드에 적용됨</li>\n<li>Diffing 알고리즘 적용 : 실제 DOM에 필요한 변경사항을 최소화하기 위해 Diffing 알고리즘을 적용하여 current와 workInProgress를 비교한다.</li>\n<li>커밋 단계 : 더블 버퍼링 메커니즘으로, current 트리를 workInProgress 트리로 교체한다. 그리고 이 트리가 UI에 최종적으로 렌더링되어 반영된다.</li>\n</ol>\n<h2>파이버 (FiberNode 생성자함수에 의해 생성된 인스턴스)</h2>\n<ul>\n<li>하나의 element 마다 생성됨</li>\n<li>파이버간의 관계는 child, sibling, return, index 프로퍼티로 표현</li>\n<li>alternate : 반대편 트리 파이버를 가리킴</li>\n</ul>\n<h2>파이버 트리 2개</h2>\n<ol>\n<li>current 트리 : 현재 화면에 렌더링된 UI 트리</li>\n<li>workInProgress 트리 : 업데이트가 진행중인 상태를 나타내는 트리</li>\n</ol>\n<h1>파이버 아키텍처 기반의 리액트 렌더링 프로세스</h1>\n<h3><strong>렌더 단계</strong></h3>\n<ol>\n<li><strong>workInProgress 트리 생성</strong>:\n<ul>\n<li>렌더 단계가 시작되면, <strong><code>current</code></strong> 트리의 복사본으로 <strong><code>workInProgress</code></strong> 트리가 생성된다.</li>\n</ul>\n</li>\n<li><strong>workInProgress 트리 탐색</strong>:\n<ul>\n<li>리액트는 <strong><code>workInProgress</code></strong> 트리를 루트부터 업데이트가 필요하다고 지정돼있는 모든 컴포넌트들을 탐색한다. 변경이 필요한 컴포넌트를 발견하면(변경 감지) 클래스형 컴포넌트이면 <strong><code>render</code></strong> 메서드 또는 함수형 컴포넌트이면 <code>**함수 자체**</code>가 호출되어 반환된 결과(render() 또는 return)가 workInProgress 트리의 해당 파이버 노드로 저장된다. 이런식으로 탐색하여 모든 변경사항을 workInProgress 트리에 반영한다.</li>\n</ul>\n</li>\n<li><strong>리액트의</strong> <strong>재조정 과정(Reconciliation)</strong>: DOM 반영이 필요한 컴포넌트를 체크하는 단계\n<ul>\n<li>효율적으로 최소한의 DOM 업데이트를 하기위해 재조정 과정을 거친다.\n<strong><code>workInProgress</code></strong> 트리와 <strong><code>current</code></strong> 트리 사이에서 type, key, props를 기준으로 변경 사항을 식별한다.(type, key가 변경되면 새로운 노드를 생성하고, 만약 type, key가 동일하다면 props 변경을 기준으로 식별)\n<ul>\n<li><strong>Fiber 노드에 효과 태그로 업데이트 표시</strong>:\n각 <strong><code>Fiber</code></strong> 노드를 검사한다.  변경이 필요한 파이버 노드에 효과 태그를 할당한다(추가, 삭제, 업데이트에 따라 효과태그가 다름)</li>\n<li><strong>업데이트 큐</strong>:\n변경이 감지된 컴포넌트의 <strong><code>Fiber</code></strong> 노드에 업데이트 큐를 생성하거나 업데이트한다. 이 업데이트 큐에는 상태 변경, props 변경 등의 정보가 포함될 수 있다.</li>\n<li><strong>효과 리스트(Effect List)</strong>:\n효과 태그가 할당된(변경 사항이 체크된) <strong><code>Fiber</code></strong> 노드는 효과 리스트(Effect List)에 추가됩니다. 이 효과 리스트는 커밋 단계에서 실제 DOM에 적용할 변경 사항들의 목록을 나타냅니다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>렌더 단계 완성</strong>:\n<ul>\n<li><code>**workInProgress</code>** 트리에 모든 변경사항이 적용되고 필요한 업데이트가 계산되면 렌더 단계가 완성되며, <strong><code>workInProgress</code></strong> 트리는 커밋 단계로 넘어갈 준비가 된다.</li>\n</ul>\n</li>\n<li><strong>중단 및 재개</strong>: 리액트 파이버는 렌더단계를 비동기로 작동하게 할 수 있음(이게 스택조정자는 동기였음)\n<ul>\n<li>리액트는 렌더단계를 비동기로 작동해 특정 렌더링의 우선순위를 낮추거나, 중단, 재시작, 폐기할 수 있다.\n<ul>\n<li>이를 통해 브라우저의 동기 작업을 차단하지 않고 백그라운드에서 새로운 리액트 트리를 준비할 수도있으므로 사용자는 더욱 매끄러운 UX를 누릴수있다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3><strong>커밋 단계</strong></h3>\n<ol>\n<li><strong>실제 DOM에 변경 사항 렌더링</strong>:\n<ul>\n<li>효과 리스트를 순회하며, 각 <strong><code>Fiber</code></strong> 노드에 표시된 변경 사항을 실제 DOM에 반영한다.</li>\n</ul>\n</li>\n<li><strong>current 트리로 교체</strong>:\n<ul>\n<li>DOM 업데이트가 완료되면, <strong><code>current</code></strong> 트리는 <strong><code>workInProgress</code></strong> 트리로 교체된다.\n(모든 DOM 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트함)</li>\n</ul>\n</li>\n<li><strong>라이프사이클 메소드 및 후크 호출</strong>:\n<ul>\n<li>클래스형 컴포넌트의 경우, 라이프사이클 메서드(<strong><code>componentDidMount</code></strong>, <strong><code>componentDidUpdate</code></strong>)를 호출한다. 함수형 컴포넌트의 경우, **<code>useLayoutEffect</code>**훅을 호출한다.</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는것은 아니다.\n렌더단계에서 변경사항을 계산했는데 아무런 변경사항이 감지되지 않는다면 커밋단계는 생략될 수 있다.</p>\n</blockquote>\n"}]}