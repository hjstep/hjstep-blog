{"posts":[{"attributes":{"title":"[시리즈] 리액트 원리 파헤치기 05 - useState의 state는 어떻게 구현되어 있을까?","summary":"리액트 파헤치기 시리즈 05 - useState 02","tag":["리액트 파헤치기 시리즈","REACT","useState"],"idx":5},"htmlBody":"<p>바로 이전 포스팅에서 useState가 정의된 곳에 대해 코드레벨에서 살펴보았다.<br>\n그곳은 컴포넌트 상태에 따라 mountState 또는 updateState였다.<br>\n그 중 mountState를 까보자.<br>\n<img src=\"../../static/img/series/react/HooksDispatcherOnMount.png\" alt=\"HooksDispatcherOnMount\"></p>\n<h2>mountState 함수</h2>\n<p><img src=\"../../static/img/series/react/mountState.png\" alt=\"mountState\"></p>\n<ul>\n<li>\n<p><code>const hook = mountStateImpl(initialState)</code>\nmountStateImpl 함수를 통해 hook을 전달받고 있다.</p>\n<p><img src=\"../../static/img/series/react/mountStateImpl.png\" alt=\"mountStateImpl\"></p>\n<ul>\n<li>\n<p><code>const hook = mountWorkInProgressHook();</code>를 호출하고 있다.\nmountWorkInProgressHook 함수는 hook 객체가 정의되어있다.</p>\n<p><img src=\"../../static/img/series/react/mountWorkInProgressHook.png\" alt=\"mountWorkInProgressHook\"></p>\n<pre><code class=\"language-javascript\">const hook: Hook  = {\n    memoizedState: null,\n    baseState: null,\n    baseQueue: null,\n    queue: null,\n    next: null\n}\n</code></pre>\n<ul>\n<li>memoizedState 프로퍼티는 마지막으로 기억하고있는 계산된 state값이다.</li>\n<li>next 프로퍼티는 다음 hook을 가리키는 포인터 역할이다.</li>\n</ul>\n<pre><code class=\"language-javascript\">if (workInProgressHook === null) {\n  currentlyRenderingFiber.memoizedState = workInProgressHook = hook;\n} else {\n  workInProgressHook = workInProgressHook.next = hook;\n}\n</code></pre>\n<ul>\n<li>\n<p>조건절 <code>workInProgressHook === null</code></p>\n<ul>\n<li>true : 작업중인 훅이 없다면 currentlyRenderingFiber.memoizedState와 workInProgressHook에 hook을 주입하고</li>\n<li>false : 작업중인 훅이 존재한다면\nworkInProgressHook.next에 hook정보를 주입하고, workInProgressHook은 next에 hook이 주입된 hook이 할당되게된다. (<strong>바로 이 부분으로 인해 링크드 리스트 구조로 next를 통해 hook끼리 연결되게 된다.</strong>)</li>\n</ul>\n</li>\n<li>\n<p>workInProgressHook을 리턴한다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>다시 mountStateImpl을 보자.\n<img src=\"../../static/img/series/react/mountStateImpl.png\" alt=\"mountStateImpl\"></p>\n<ul>\n<li>\n<p>인자로 받은 initialState를 hook.memoizedState와 hook.baseState에 저장하고 있다.</p>\n</li>\n<li>\n<p>이때 initialState가 함수이면 함수를 호출한 결과값을 저장한다. (<strong>바로 우리가 useState인자로 함수를 넘기면 발생하게 되는 코드이며, 게으른 초기화가 여기서 이루어진다</strong>)</p>\n</li>\n<li>\n<p>queue 객체 : 상태를 업데이트할 때 필요한 정보들을 담고 있는 객체이며, dispatch가 상태를 업데이트하는 함수이다. (다음 포스팅에 자세히 설명하겠다)</p>\n</li>\n<li>\n<p>hook을 리턴한고 함수를 종료한다.</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>mountState 나머지 부분을 보자.\n<img src=\"../../static/img/series/react/mountState02.png\" alt=\"mountState02\"></p>\n<ul>\n<li>\n<p>dispatch는 상태 업데이트 함수이다.</p>\n<ul>\n<li>dispatch는 dispatchSetState함수를 bind하고있는데, 이때 인자들은 currentlyRenderingFiber(현재 fiber)와 queue이다.</li>\n<li>우리가 setState 인자로 받는 부분이 바로 이 코드를 통해 이루어진다.</li>\n</ul>\n</li>\n<li>\n<p><code>return [hook.memoizedState, dispatch]</code></p>\n<ul>\n<li>즉, useState 함수 리턴값 배열의 첫번째 원소는 hook.memoizedState가 들어가게되고(<strong>state</strong>), 두번째 원소는 dispatch가 상태 업데이트 함수(<strong>setState</strong>)로 들어가게된다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>정리</h2>\n<p>우리가 useState 호출을 통해 리턴받는 배열은 바로 <code>return [hook.memoizedState, dispatch]</code> 이 부분이며, 첫번째 원소로는 기억하고있는 상태값인 <strong>hook.memoizedState</strong>이고 두번째 원소로는 상태 업데이트 함수인 <strong>dispatch</strong>이다.</p>\n<h2>마치며</h2>\n<p>이번 포스팅에서는 useState의 state가 어떻게 구현되어있는지 살펴보았고 setState에 대해서도 간략히 살펴보았다.<br>\n다음 포스팅에서 setState에 대해 자세히 알아보자.</p>\n"},{"attributes":{"title":"[시리즈] 리액트 원리 파헤치기 04 - useState가 정의된 곳","summary":"리액트 파헤치기 시리즈 04 - useState 01","tag":["리액트 파헤치기 시리즈","REACT","useState"],"idx":4},"htmlBody":"<p>본격적으로 useState를 코드레벨에서 까보면서 useState는 어떻게 구현되어있는지, 그리고 reconciler가 무슨 역할을 하는지에 대해 알아보자.<br>\n&quot;<strong>useState 정의된 위치 -&gt; useState의 state -&gt; useState의 setState</strong>&quot; 순서로 포스팅을 작성하려고 한다.<br>\n그럼 이번 포스팅에는 useState가 정의된 위치가 어디인지 파헤쳐보자.</p>\n<p>우리가 분석할 패키지는 react, shared, react-reconciler 패키지이다.<br>\n각 패키지에 대해 간단히 소개하자면</p>\n<ol>\n<li><strong>react 패키지</strong> : react 패키지는 코어 패키지이며, react element가 정의되어있고 그 외는 shared 패키지를 통해 주입받고있다.</li>\n<li><strong>react-reconciler</strong> : react-reconciler는 react element를 VDOM에 반영하기 위해 fiber node로 확장하는 패키지이다.</li>\n<li><strong>shared 패키지</strong> : shared 패키지는 패키지들끼리 의존성을 갖는 부분에 대해 정의되어있는 패키지이며, 통로 역할을 한다.</li>\n</ol>\n<p>그럼 react 패키지 진입점부터 확인해보자.</p>\n<h2>react/index.js</h2>\n<p>이 파일은 단순히 <code>react/src/ReactClient.js</code>에서 받아온 정보들을 export하고 있다.</p>\n<h2>react/src/ReactClient.js</h2>\n<p><img src=\"../../static/img/series/react/ReactClient.png\" alt=\"ReactClient\"><br>\n<img src=\"../../static/img/series/react/ReactClient02.png\" alt=\"ReactClient02\"></p>\n<p>ReactClient에서 ReactHooks의 useState를 import하여 export하고 있다.</p>\n<h2>react/src/ReactHooks.js</h2>\n<p><img src=\"../../static/img/series/react/ReactHooks.png\" alt=\"ReactHooks\"></p>\n<p>여기에 useState가 정의되어 export되고 있고,<br>\nresolveDispatcher함수에서 꺼내오는걸 확인할 수 있다.</p>\n<ul>\n<li>resolveDispatcher 함수\n<img src=\"../../static/img/series/react/ReactHooks02.png\" alt=\"resolveDispatcher\"><br>\nReactCurrentDispatcher.current에서 꺼내오고 리턴한다.</li>\n</ul>\n<h2>react/src/ReactCurrentDispatcher.js</h2>\n<p><img src=\"../../static/img/series/react/ReactCurrentDispatcher.png\" alt=\"ReactCurrentDispatcher\"><br>\nReactCurrentDispatcher.current에는 null이 할당되어있다.</p>\n<p>여기까지 확인해보면 react 패키지에는 hook에 대한 코드가 없는 것으로 확인할 수 있다.<br>\n(밑에서 확인해보겠지만, hook 정보는 reconciler가 관리하고 있다.)</p>\n<h2>react/src/ReactSharedInternalsClient.js</h2>\n<p><img src=\"../../static/img/series/react/ReactSharedInternalsClient.png\" alt=\"ReactSharedInternalsClient\"><br>\n여기서 ReactCurrentDispatcher를 import하여\nReactSharedInternals 객체의 프로퍼티로 할당하고 있다.<br>\n즉, reconciler로 부터 hook 정보를 ReactSharedInternals를 통해 주입받는 구조인 것이다.<br>\n따라서 shared 패키지의 ReactSharedInternals를 확인해보자.</p>\n<h2>shared/ReactSharedInternals.js</h2>\n<p><img src=\"../../static/img/series/react/ReactSharedInternals.png\" alt=\"ReactSharedInternals\"><br>\n여기에 정보를 주입하면 react/src/ReactSharedInternals.js 여기로 전달이 되는 구조다.<br>\n전달되는 형태에 대해서는 추후에 자세히 알아볼것이니 지금은 이러한 구조라는 것에 대해 기억하자.</p>\n<p>이제 실질적으로 hook정보를 주입해주는 reconciler 패키지를 뜯어보자.</p>\n<h2>react-reconciler/src/ReactFiberHooks.js</h2>\n<ul>\n<li>\n<p>shared 패키지의 ReactSharedInternals를 import한다.\n<img src=\"../../static/img/series/react/ReactFiberHooks01.png\" alt=\"ReactFiberHooks01\"></p>\n</li>\n<li>\n<p>ReactSharedInternals에서 ReactCurrentDispatcher를 꺼내온다.<br>\n<img src=\"../../static/img/series/react/ReactFiberHooks02.png\" alt=\"ReactFiberHooks02\"></p>\n</li>\n</ul>\n<h3>renderWithHooks 함수</h3>\n<ul>\n<li>\n<p>ReactCurrentDispatcher.current는 renderWithHooks 함수에서 할당해주고 있다.\n<img src=\"../../static/img/series/react/renderWithhooks01.png\" alt=\"renderWithhooks01\"></p>\n</li>\n<li>\n<p>조건절 <code>current === null || current.memoizedState === null</code>\n현재 current 트리가 없다는 뜻이며, 컴포넌트가 Mount 상태라는 것이다.</p>\n<ul>\n<li>\n<p>true이면, 마운트 hook정보인 HooksDispatcherOnMount를 주입한다.</p>\n</li>\n<li>\n<p>false이면, 업데이트 상태라는 것이므로 HooksDispatcherOnUpdate를 주입한다.</p>\n</li>\n<li>\n<p>HooksDispatcherOnMount와 HooksDispatcherOnUpdate는 hook 정보들이 담겨있는 객체이다.<br>\n<img src=\"../../static/img/series/react/HooksDispatcherOnMount.png\" alt=\"HooksDispatcherOnMount\"><br>\n<img src=\"../../static/img/series/react/HooksDispatcherOnUpdate.png\" alt=\"HooksDispatcherOnUpdate\"><br>\n<strong>여기서 useState가 mount상태면 mountState, 업데이트상태면 updateState가 할당되는 것을 확인할 수 있다.</strong></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2>정리</h2>\n<p>정리하자면 useState가 정의된 곳은 react-reconciler의 ReactFiberHooks에서 mountState, updateState 함수이며, useState의 실체는 mountState 또는 updateState인 것이다.</p>\n<h2>마치며</h2>\n<p>이제 정의된 위치에 대해 살펴보았으니, mountState 함수를 까보면서 useState 내부 코드에 대해 알아보자.</p>\n"},{"attributes":{"title":"[시리즈] 리액트 원리 파헤치기 03 - VDOM과 reconciler","summary":"리액트 파헤치기 시리즈 03 - VDOM과 reconciler","tag":["리액트 파헤치기 시리즈","REACT"],"idx":3},"htmlBody":"<p>virtual DOM이라고 하는 VDOM과 reconciler에 대해 알아보자.</p>\n<h2>VDOM은 리액트의 렌더링 컨셉이다.</h2>\n<p>UI 정보를 가진 가상 DOM과 실제 DOM을 비교하여(재조정) 업데이트된 부분만 일괄로 브라우저에 반영한다라는 컨셉이다.<br>\n왜 가상에서 하냐면 실제 DOM을 조작하면서 paint하면 가상으로 하는것보다 훨씬 더 비용이 들기 때문이다.<br>\n따라서 리액트는 가상 DOM과 렌더링 과정 최적화(재조정 reconciliation)를 통해 렌더링을 지원하는 라이브러리이다.</p>\n<p>그렇다면 리액트의 렌더링 방식은 어떤 설계방식(아키텍쳐)로 이루어져있을까?<br>\n그건 바로 리액트 파이버이다.</p>\n<h2>VDOM의 구현</h2>\n<p>리액트 파이버아키텍쳐에서 VDOM은 FiberNode 생성자 함수로 생성한 객체들의 집합으로 이루어진 트리 구조이다.<br>\n이 파이버 트리는 애플리케이션의 구조와 상태를 나타내며 current트리와 workInProgress 트리 2개가 존재한다.</p>\n<ol>\n<li><strong>current 트리</strong></li>\n</ol>\n<ul>\n<li>현재 UI 렌더링 정보가 담긴 파이버 트리</li>\n</ul>\n<ol start=\"2\">\n<li><strong>workInProgress 트리</strong></li>\n</ol>\n<ul>\n<li>작업중인 상태를 나타내는 트리</li>\n</ul>\n<p>왜 2개가 존재하냐면 더블 버퍼링 구조로 설계되어 있기때문에 원본 트리와 작업중 트리를 가지고 있으며,<br>\n렌더링 순서를 유연하게 조작하기 위해서는 원본이 필요하기 때문이다.\n즉, 업데이트가 발생하면 current tree를 복제하여 workInProgress tree가 생성되고<br>\n이 workInProgress tree에 변경사항을 업데이트하고 재조정 과정을 거쳐 render phase가 끝나고 commit phase에서 current tree로 교체된다.</p>\n<h2>reconciler</h2>\n<p>reconciler는 업데이트를 감지하여 workInProgress 트리를 만들고  current트리와 workInProgress 트리를 비교하여 실제 DOM에 적용할 업데이트사항을 결정하는 역할을 한다.</p>\n<h2>라이프사이클</h2>\n<p>리액트에서 라이프사이클 단계는 render phase단계와 commit phase단계로 이루어져있다.</p>\n<ol>\n<li><strong>render phase</strong></li>\n</ol>\n<ul>\n<li>VDOM을 재조정(reconciliation)하는 단계이다.</li>\n<li>이 과정은 비동기로 실행될 수 있다.(이전 stack아키텍처는 이부분이 동기적으로 발생되었었음)</li>\n</ul>\n<ol start=\"2\">\n<li><strong>commit phase</strong></li>\n</ol>\n<ul>\n<li>재조정한 VDOM을 실제 DOM에 일괄 반영하고 라이프사이클 메소드 또는 훅을 실행하는 단계이다.</li>\n<li>이 과정은 동기적으로 실행된다.</li>\n</ul>\n<h2>마치며</h2>\n<p>이번에는 VDOM과 reconciler가 무엇인지에 대해 간략히 알아보았다.<br>\n복잡하게 생각할 필요없이 결국 리액트는 VDOM과 reconciler라는 컨셉을 통해 렌더링 과정을 최적화하는 라이브러리라는 것을 기억하자.<br>\n다음은 useState를 코드 레벨에서 까보면서 reconciler가 어떤 역할을 하는지 자세히 알아보자.</p>\n"},{"attributes":{"title":"[시리즈] 리액트 원리 파헤치기 02 - react element","summary":"리액트 파헤치기 시리즈 02 - react element","tag":["리액트 파헤치기 시리즈","REACT"],"idx":2},"htmlBody":"<p>fiber node 객체에 대해 살펴보기전에 react element가 무엇인지 정확히 알고 넘어갈 필요가 있다.<br>\nreact element가 무엇인지에 대해 살펴보자</p>\n<h2>react element란?</h2>\n<p>react element는 컴포넌트 관련 정보를 갖고 있는 객체이다. type, key, props, ref 등의 프로퍼티를 소유하고 있다.<br>\nreact element 종류로는 DOM elements와 Component elements가 있다.</p>\n<p>우리가 리액트 컴포넌트를 작성할때 JSX문법으로 작성하면 그것을 트랜스파일링하여 react element 형태를 리턴받게 된다.<br>\n이 과정을 좀더 자세하게 설명하자면 다음과 같다.</p>\n<pre><code class=\"language-javascript\">컴포넌트를 호출 -&gt; 리턴한 DOM elements (JSX 문법) -&gt; 트랜스파일링 -&gt; react.createElement()를 호출 -&gt; react element를 리턴받음\n</code></pre>\n<p>컴포넌트를 호출했을때 Component elements를 리턴받으면 DOM elements를 리턴할때까지 계속해서 순회하여 호출하게 된다. 결국 DOM elements로 구성되어있는 element tree가 완성된다.</p>\n<h2>react element의 종류</h2>\n<p>종류는 DOM elements, Component elements 2가지 종류가 있다.<br>\n<code>(type: string | ReactClass, props: object)</code><br>\n이때 type이 string이면 DOM elements이며, ReactClass이면 Component elements이다.</p>\n<ol>\n<li>DOM elements</li>\n</ol>\n<ul>\n<li>type: string</li>\n<li>props: html태그의 attribute</li>\n</ul>\n<pre><code class=\"language-javascript\">&lt;button className=&quot;btn-red&quot;&gt;\n    confirm\n&lt;/button&gt;\n\n// 트랜스파일링 결과\n{\n  type: 'button',\n    props: {\n      className: 'btn-red',\n      children: 'confirm'\n    }\n}\n</code></pre>\n<ol start=\"2\">\n<li>Component elements</li>\n</ol>\n<ul>\n<li>type: ReactClass</li>\n<li>props: DOM 렌더링에 필요한 정보들</li>\n</ul>\n<pre><code class=\"language-javascript\">&lt;Button color=&quot;red&quot;&gt;confirm&lt;/Button&gt;\n\n// 트랜스파일링 결과\n{\n    type: Button,\n    props: {\n        color: 'red',\n        children: 'confirm'\n    }\n}\n</code></pre>\n<p>Component elements는 DOM elements를 캡슐화한 것이다.<br>\n해당 컴포넌트를 호출하면 DOM elements를 결국 return 하게 된다.</p>\n<pre><code class=\"language-javascript\">&lt;Button color=&quot;red&quot;&gt;confirm&lt;/Button&gt;\n\nfunction Button(props) {\n  return (\n\t&lt;button className={props.color}&gt;\n\t\tconfirm\n\t&lt;/button&gt;\n  )\n}\n</code></pre>\n<h2>정리</h2>\n<p>즉 Component elements로 개발자가 직접 DOM 트리에 전달할 정보를 정의할 수 있고<br>\n각각의 elements들이 elements tree 구조로 이루어 DOM 트리에 전달할 정보를 가지고 있게 되는 자바스크립트 객체인 것이다.</p>\n<h2>마치며</h2>\n<p>사실 react element는 fiber node로 확장되어 VDOM에 반영되게 된다.<br>\n이는 앞으로 자세하게 알아볼 것이니 react element가 무엇인지에 대해서만 기억하자</p>\n"},{"attributes":{"title":"[시리즈] 리액트 원리 파헤치기 01 - Intro","summary":"리액트 파헤치기 시리즈 01 - 사전지식","tag":["리액트 파헤치기 시리즈","REACT"],"idx":1},"htmlBody":"<p>리액트 원리를 깊게 파악하고 싶어서 <strong>&quot;리액트 원리 파헤치기&quot;</strong> 시리즈를 작성하려고 한다.<br>\n이 시리즈는 리액트 아키텍쳐와 리액트 패키지가 어떻게 구성되어있는지, 동작 원리는 무엇인지 파헤쳐보는 시리즈이다.<br>\n본격적으로 시리즈에 들어가기 앞서 리액트 원리를 이해하는데 필요한 배경과 사전지식에 대해 알아보자</p>\n<h2>배경</h2>\n<p>리액트 16버전 이전에는 <strong>Stack Reconciler 아키텍쳐</strong>로 구성되어 있었다.<br>\nstack 자료구조 형태이기 때문에 LIFO 형태로 마지막에 들어간 task를 먼저 렌더링해야만 하는 고정적인 순서가 있었고, 동기적으로 컴포넌트 트리를 업데이트해야만 했다.<br>\n이는 업데이트가 크게 발생하면 브라우저 메인 스레드를 블로킹하므로 마치 UI가 멈춘것처럼 느껴지게 하는 좋지않은 UX를 안겨주었고,\n렌더링 순서도 마음대로 변경하거나 일시중단할 수 없었다.<br>\n특히 복잡한 애플리케이션에서 렌더링 성능에 악영향을 미쳤다.<br>\n따라서 이러한 문제를 해결하기 위해 Fiber 아키텍쳐가 도입되었다.</p>\n<h2>Fiber 아키텍쳐란?</h2>\n<p>리액트 16에 등장한 렌더링 아키텍쳐로, Stack 아키텍쳐의 문제점을 해결하기 위해 등장했다.(물론 본격적으로 파이버 아키텍쳐가 사용되기 시작한 버전은 리액트 18버전 부터(useTransition, usedeferredvalue))<br>\n메인 스레드가 블로킹되는 것을 방지하고 비동기적으로 업데이트가 발생하므로 렌더링 task를 일시중단하거나 재개할 수 있으며, 또한 우선순위를 부여하여 우선순위 기반의 스케줄링을 할 수 있다.<br>\n메인 스레드가 블로킹되지 않기 때문에 이전의 Stack 아키텍쳐보다 UX가 향상되었다.</p>\n<h2>알아두어야할 사전지식</h2>\n<p>여기까지 리액트 렌더링 아키텍쳐의 배경과 개념에 대해 간략하게 알아보았다.<br>\n이제 알아두어야할 사전지식들에 대해서 설명하겠다.<br>\n설명할 사전지식들의 목차는 다음과 같다.</p>\n<pre><code class=\"language-javascript\">1. 리액트에서의 렌더링 개념\n2. react element란?\n3. fiber 노드란?\n</code></pre>\n<p>각각에 대해 알아보자</p>\n<h3>1. 리액트에서의 렌더링 개념</h3>\n<p>리액트에서 렌더링이라고 부르는 개념과 우리가 흔히 알고있는 렌더링 개념은 조금 차이가 있다.<br>\n리액트에서의 렌더링은 컴포넌트를 호출하고 VDOM 재조정 작업까지를 렌더링이라고 하며, 브라우저에 반영되는 것은 이후 commit phase에서 진행한다.<br>\n정리하자면 우리가 알고있는 렌더링은 브라우저에 반영까지인데, 리액트에서 렌더링은 렌더링 재조정자가 진행하는 과정까지를 말한다. 헷갈리지않게 숙지하자.</p>\n<h3>2. react element란?</h3>\n<p>컴포넌트가 리턴한 JSX를 트랜스파일링하여 결국 <code>react.createElement()</code>를 호출하게된다.(요즘은 jsxRuntime) 이때 리턴한 내용을 <strong>react element</strong>라고 한다.<br>\nreact element란 DOM에 적용될 내용이 담긴(컴포넌트 정보들) 객체인데 type, key, props, ref 프로퍼티로 구성되어있다.</p>\n<h3>3. fiber 노드란?</h3>\n<p>react element를 확장한 것으로 VDOM의 노드 객체를 말한다.<br>\nreact element에서 state, 라이프사이클, hook이 추가된 노드이다.(VDOM은 DOM에 반영될 정보가 담겨있다)</p>\n<h2>마치며</h2>\n<p>여기까지 리액트 원리 파헤치기 시리즈에 들어가기 앞서 사전지식들에 대해 작성해보았다.<br>\n다음은 react element가 무엇인지 파헤쳐보자.</p>\n"}]}