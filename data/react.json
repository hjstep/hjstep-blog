{"posts":[{"attributes":{"title":"[시리즈] 리액트 원리 파헤치기 06 - useState의 setState 동작 방식, 만약 setState를 여러번 호출한다면?","summary":"리액트 파헤치기 시리즈 - useState 3","tag":["리액트 파헤치기 시리즈","REACT","useState"],"idx":6},"htmlBody":"<p>이번 포스팅에서는 useState의 setter함수인 setState 동작 방식과 이를 여러번 호출한다면 어떤일이 발생할지에 대해 알아보겠다.<br>\n컴포넌트가 mount되는 시점에, setState를 호출하는 케이스를 바탕으로 작성하겠다.</p>\n<blockquote>\n<p>코드는 필요없는 주석과 개발모드를 제외하고 가져왔다.</p>\n</blockquote>\n<p>컴포넌트가 마운트될때 useState에 할당되는 함수는 <strong>mountState</strong>이다.</p>\n<h3>mountState</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">function</span> mountState&lt;S&gt;(\n  <span class=\"hljs-attr\">initialState</span>: (<span class=\"hljs-function\">() =&gt;</span> S) | S,\n): [S, <span class=\"hljs-title class_\">Dispatch</span>&lt;<span class=\"hljs-title class_\">BasicStateAction</span>&lt;S&gt;&gt;] {\n  <span class=\"hljs-keyword\">const</span> hook = <span class=\"hljs-title function_\">mountWorkInProgressHook</span>();\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> initialState === <span class=\"hljs-string\">&#x27;function&#x27;</span>) {\n    initialState = <span class=\"hljs-title function_\">initialState</span>();\n  }\n  hook.<span class=\"hljs-property\">memoizedState</span> = hook.<span class=\"hljs-property\">baseState</span> = initialState;\n  <span class=\"hljs-keyword\">const</span> queue = (hook.<span class=\"hljs-property\">queue</span> = {\n    <span class=\"hljs-attr\">last</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">dispatch</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">lastRenderedReducer</span>: basicStateReducer,\n    <span class=\"hljs-attr\">lastRenderedState</span>: (<span class=\"hljs-attr\">initialState</span>: any),\n  });\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">dispatch</span>: <span class=\"hljs-title class_\">Dispatch</span>&lt;\n    <span class=\"hljs-title class_\">BasicStateAction</span>&lt;S&gt;,\n  &gt; = (queue.<span class=\"hljs-property\">dispatch</span> = (dispatchAction.<span class=\"hljs-title function_\">bind</span>(\n    <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-comment\">// Flow doesn&#x27;t know this is non-null, but we do.</span>\n    ((<span class=\"hljs-attr\">currentlyRenderingFiber</span>: any): <span class=\"hljs-title class_\">Fiber</span>),\n    queue,\n  ): any));\n  <span class=\"hljs-keyword\">return</span> [hook.<span class=\"hljs-property\">memoizedState</span>, dispatch];\n}\n</code></pre>\n<p>mountState에서  <strong>return 배열의 두번째 원소(dispatch)가 바로 setter함수인 setState이다.</strong><br>\ndispatch는 dispatchAction 함수에 인자가 바인딩되어있는 형태이다.<br>\ndispatchAction 함수를 보자.</p>\n<h3>dispatchAction</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">function</span> dispatchAction&lt;S, A&gt;(\n  <span class=\"hljs-attr\">fiber</span>: <span class=\"hljs-title class_\">Fiber</span>,\n  <span class=\"hljs-attr\">queue</span>: <span class=\"hljs-title class_\">UpdateQueue</span>&lt;S, A&gt;,\n  <span class=\"hljs-attr\">action</span>: A,\n) {\n  <span class=\"hljs-keyword\">const</span> alternate = fiber.<span class=\"hljs-property\">alternate</span>;\n  <span class=\"hljs-keyword\">if</span> (\n    fiber === currentlyRenderingFiber ||  <span class=\"hljs-comment\">// fiber는 current 또는 workInProgress임, </span>\n    (alternate !== <span class=\"hljs-literal\">null</span> &amp;&amp; alternate === currentlyRenderingFiber)<span class=\"hljs-comment\">// 따라서 fiber가 workInProgress가 아니면 alternate가 workInProgress인 것이므로 그걸 체크하는것</span>\n  ) {\n      <span class=\"hljs-comment\">// ...</span>\n  } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">// ...</span>\n  }\n}\n</code></pre>\n<p>조건절을 보면, currentlyRenderingFiber(현재 렌더링중인 fiber)가 fiber(current 또는 workInProgress) 동일하거나<br>\nfiber.alternate(current이면 workInProgress, workInProgress이면 current)가 currentlyRenderingFiber와 동일한지 체크한다.<br>\n이게 무슨 의미냐면 render Phase인지 체크하는 조건이다.<br>\n컴포넌트는 기본 상태였다가 스케쥴에 등록되면 -&gt; render phase에 진입하게 된다.<br>\n즉, render phase에서 상태업데이트가 발생한것인지 or 기본 상태에서 상태 업데이트가 발생한 것인지에 따라 setState를 처리하는 방식이 다르다.</p>\n<p>그런데 이때 왜 fiber와 alternate 둘다 체크하냐면, fiber는 current가 될수도 있고 workInProgress도 될 수 있는 더블 버퍼링 구조이기 때문에 둘 다 체크하는 것이다.</p>\n<h3>dispatchAction의 기본 상태 로직</h3>\n<p>그럼 기본 상태일 때(else 부) 로직을 살펴보자.</p>\n<h4>1. <strong>update 객체 생성</strong></h4>\n<pre class=\"hljs\"><code>\n<span class=\"hljs-comment\">/* 다음시간에 분석예정 패스\nconst currentTime = requestCurrentTimeForUpdate();\nconst suspenseConfig = requestCurrentSuspenseConfig();\nconst expirationTime = computeExpirationForFiber(\n    currentTime,\n    fiber,\n    suspenseConfig,\n);*/</span>\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">update</span>: <span class=\"hljs-title class_\">Update</span>&lt;S, A&gt; = {\n    expirationTime,\n    suspenseConfig,\n    action,<span class=\"hljs-comment\">// setState에 인자로 넣어주는것</span>\n    <span class=\"hljs-attr\">eagerReducer</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">eagerState</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">next</span>: <span class=\"hljs-literal\">null</span>,<span class=\"hljs-comment\">// 다음 노드의 레퍼런스값 저장</span>\n};\n</code></pre>\n<p>update 객체를 생성한다. 이때 <strong>우리가 setState에 넘긴 인자인 action을 프로퍼티로 넣는다</strong><br>\neagerState는 예상상태로 action을 적용했을때 바뀔 상태를 의미하고<br>\nnext는 다음 노드의 레퍼런스 값을 가리키는 포인터 역할을 한다. 이를 통해 우리는 링크드 리스트 구조라는 것을 알 수 있다.</p>\n<h4>2. <strong>queue.last에 update객체 저장(순환 링크드 리스트 구조)</strong></h4>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 순환 링크드 리스트 구조로 update를 queue에 저장하고있다.</span>\n<span class=\"hljs-keyword\">const</span> last = queue.<span class=\"hljs-property\">last</span>;\n<span class=\"hljs-keyword\">if</span> (last === <span class=\"hljs-literal\">null</span>) {\n    update.<span class=\"hljs-property\">next</span> = update;\n} <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">const</span> first = last.<span class=\"hljs-property\">next</span>;\n    <span class=\"hljs-keyword\">if</span> (first !== <span class=\"hljs-literal\">null</span>) {\n    <span class=\"hljs-comment\">// Still circular.</span>\n    update.<span class=\"hljs-property\">next</span> = first;\n    }\n    last.<span class=\"hljs-property\">next</span> = update;\n}\nqueue.<span class=\"hljs-property\">last</span> = update;\n</code></pre>\n<p>queue객체의 last 프로퍼티에 update객체를 할당하는데, 여기서 setState를 여러번 호출하는 경우 또 이 부분이 타게 되면서<br>\n순환 링크드 리스트 구조로 <strong>queue.last.next는 첫번째 업데이트를, queue.last는 마지막 업데이트를 가리키게된다.</strong></p>\n<ul>\n<li>\n<p>순환 링크드 리스트 구조</p>\n<ul>\n<li>순환 링크드 리스트 구조는 링크드 리스트 구조인데, 마지막 노드의 next가 항상 첫번째 노드를 가리키도록 하는 구조이다.</li>\n</ul>\n<p><img src=\"../../static/img/series/react/circular-linked-list.png\" alt=\"circular-linked-list\"></p>\n</li>\n<li>\n<p>순환 링크드 리스트 구조로 관리하는 이유는 배치 업데이트를 효율적으로 처리하기 위함이며, 여러 상태변경이 발생되는 경우 한번에 모든 업데이트를 순회하고 적용할 수 있다.</p>\n</li>\n</ul>\n<h4>3. 불필요한 렌더링이 발생하지 않도록 최적화</h4>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">if</span> (\n      fiber.<span class=\"hljs-property\">expirationTime</span> === <span class=\"hljs-title class_\">NoWork</span> &amp;&amp;\n      (alternate === <span class=\"hljs-literal\">null</span> || alternate.<span class=\"hljs-property\">expirationTime</span> === <span class=\"hljs-title class_\">NoWork</span>)\n    ) {\n      <span class=\"hljs-keyword\">const</span> lastRenderedReducer = queue.<span class=\"hljs-property\">lastRenderedReducer</span>;\n      <span class=\"hljs-keyword\">if</span> (lastRenderedReducer !== <span class=\"hljs-literal\">null</span>) {\n        <span class=\"hljs-keyword\">let</span> prevDispatcher;\n        <span class=\"hljs-keyword\">try</span> {\n          <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">currentState</span>: S = (queue.<span class=\"hljs-property\">lastRenderedState</span>: any);\n          <span class=\"hljs-keyword\">const</span> eagerState = <span class=\"hljs-title function_\">lastRenderedReducer</span>(currentState, action);<span class=\"hljs-comment\">// action을 적용한 예상상태</span>\n\n          update.<span class=\"hljs-property\">eagerReducer</span> = lastRenderedReducer;\n          update.<span class=\"hljs-property\">eagerState</span> = eagerState;\n          <span class=\"hljs-comment\">// 불필요한 렌더링이 발생하지않도록 최적화(이전상태와 예상상태가 같으면 return으로 함수실행종료 및 스케쥴에 work를 등록하지않는다)</span>\n          <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">is</span>(eagerState, currentState)) {\n\n            <span class=\"hljs-keyword\">return</span>;\n          }\n        } <span class=\"hljs-keyword\">catch</span> (error) {\n          <span class=\"hljs-comment\">// Suppress the error. It will throw again in the render phase.</span>\n        } <span class=\"hljs-keyword\">finally</span> {\n          <span class=\"hljs-keyword\">if</span> (__DEV__) {\n            <span class=\"hljs-title class_\">ReactCurrentDispatcher</span>.<span class=\"hljs-property\">current</span> = prevDispatcher;\n          }\n        }\n      }\n    }\n\n</code></pre>\n<p>currentState(현재 상태)와 eagerState(action을 적용한 예상 상태)를 비교하여 같으면 return으로 함수를 종료 시켜 스케쥴에 등록하지않는다.</p>\n<h4>4. update를 적용하기 위해 스케쥴에 work를 등록</h4>\n<pre class=\"hljs\"><code>    <span class=\"hljs-title function_\">scheduleWork</span>(fiber, expirationTime);<span class=\"hljs-comment\">// update를 적용하기 위해 스케쥴에 work를 등록</span>\n</code></pre>\n<h3>dispatchAction의 렌더 단계 업데이트인 경우 로직</h3>\n<p>render phase 업데이트일 때 로직을 보자.</p>\n<h4>1. didScheduleRenderPhaseUpdate 플래그를 true로 할당한다.</h4>\n<pre class=\"hljs\"><code>didScheduleRenderPhaseUpdate = <span class=\"hljs-literal\">true</span>;\n</code></pre>\n<h4>2. update 객체를 생성한다.</h4>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">update</span>: <span class=\"hljs-title class_\">Update</span>&lt;S, A&gt; = {\n    <span class=\"hljs-attr\">expirationTime</span>: renderExpirationTime,\n    <span class=\"hljs-attr\">suspenseConfig</span>: <span class=\"hljs-literal\">null</span>,\n    action,\n    <span class=\"hljs-attr\">eagerReducer</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">eagerState</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">next</span>: <span class=\"hljs-literal\">null</span>,\n};\n</code></pre>\n<h4>3. renderPhaseUpdates를 Map 자료구조로 생성하고(null이라면), queue를 키로 꺼내온다.</h4>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">if</span> (renderPhaseUpdates === <span class=\"hljs-literal\">null</span>) {\n    renderPhaseUpdates = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<span class=\"hljs-comment\">//업데이트 보관소</span>\n}\n<span class=\"hljs-keyword\">const</span> firstRenderPhaseUpdate = renderPhaseUpdates.<span class=\"hljs-title function_\">get</span>(queue);\n</code></pre>\n<h4>4. queue를 키로 갖고있는 데이터가 없다면, update를 저장한다.</h4>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">if</span> (firstRenderPhaseUpdate === <span class=\"hljs-literal\">undefined</span>) {\n    renderPhaseUpdates.<span class=\"hljs-title function_\">set</span>(queue, update);\n} <span class=\"hljs-keyword\">else</span> {\n</code></pre>\n<h4>5. 존재한다면, 링크드 리스트 형태로 마지막 노드가 나올때까지(while) 반복하여 마지막 노드.next에 update를 저장한다.</h4>\n<pre class=\"hljs\"><code>} <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 링크드 리스트 형태로 renderPhaseUpdates에 저장되고 있다. </span>\n    <span class=\"hljs-keyword\">let</span> lastRenderPhaseUpdate = firstRenderPhaseUpdate;\n    <span class=\"hljs-keyword\">while</span> (lastRenderPhaseUpdate.<span class=\"hljs-property\">next</span> !== <span class=\"hljs-literal\">null</span>) {\n    lastRenderPhaseUpdate = lastRenderPhaseUpdate.<span class=\"hljs-property\">next</span>;\n    }\n    lastRenderPhaseUpdate.<span class=\"hljs-property\">next</span> = update;\n}\n</code></pre>\n<p>렌더 단계 업데이트인 경우, update가 링크드 리스트 구조이며 이를 Map에 저장하고 있다.<br>\n이렇게 하는 이유는 렌더 단계에서의 업데이트를 추적하고 순서를 관리하기 위해 사용된다.</p>\n<p>여기까지 dispatchAction 함수 분석은 끝났다.<br>\n그렇다면 didScheduleRenderPhaseUpdate 전역변수는 어디서 활용되는 걸까?<br>\n그건 바로 renderWithHooks이다.</p>\n<h3>renderWithHooks</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">renderWithHooks</span>(<span class=\"hljs-params\">\n  current: Fiber | <span class=\"hljs-literal\">null</span>,\n  workInProgress: Fiber,\n  Component: any,\n  props: any,\n  refOrContext: any,\n  nextRenderExpirationTime: ExpirationTime,\n</span>): any {\n\n<span class=\"hljs-keyword\">let</span> children = <span class=\"hljs-title class_\">Component</span>(props, refOrContext);<span class=\"hljs-comment\">// 컴포넌트 호출이 끝나고 </span>\n\n  <span class=\"hljs-keyword\">if</span> (didScheduleRenderPhaseUpdate) {<span class=\"hljs-comment\">// true이면 렌더단계 업데이트 발생했다라는 뜻</span>\n    <span class=\"hljs-keyword\">do</span> {\n      didScheduleRenderPhaseUpdate = <span class=\"hljs-literal\">false</span>;\n      numberOfReRenders += <span class=\"hljs-number\">1</span>;\n\n      nextCurrentHook = current !== <span class=\"hljs-literal\">null</span> ? current.<span class=\"hljs-property\">memoizedState</span> : <span class=\"hljs-literal\">null</span>;\n      nextWorkInProgressHook = firstWorkInProgressHook;\n\n      currentHook = <span class=\"hljs-literal\">null</span>;\n      workInProgressHook = <span class=\"hljs-literal\">null</span>;\n      componentUpdateQueue = <span class=\"hljs-literal\">null</span>;\n\n      <span class=\"hljs-title class_\">ReactCurrentDispatcher</span>.<span class=\"hljs-property\">current</span> = __DEV__\n        ? <span class=\"hljs-title class_\">HooksDispatcherOnUpdateInDEV</span>\n        : <span class=\"hljs-title class_\">HooksDispatcherOnUpdate</span>; <span class=\"hljs-comment\">// ReactCurrentDispatcher.current에 이번엔 update hook을 할당한다.</span>\n\n      children = <span class=\"hljs-title class_\">Component</span>(props, refOrContext);<span class=\"hljs-comment\">// 컴포넌트 재호출</span>\n    } <span class=\"hljs-keyword\">while</span> (didScheduleRenderPhaseUpdate);<span class=\"hljs-comment\">// false일 때까지 반복</span>\n\n    renderPhaseUpdates = <span class=\"hljs-literal\">null</span>;\n    numberOfReRenders = <span class=\"hljs-number\">0</span>;\n  }\n\n  ...\n}\n</code></pre>\n<p>컴포넌트 호출이 끝나고 didScheduleRenderPhaseUpdate 플래그가 true이면 렌더 단계 업데이트 발생을 감지하고<br>\nnumberOfReRenders 숫자를 증가시키고 훅을 update로 교체하여 컴포넌트를 재호출한다.<br>\n위 과정은 false일 때까지 반복된다.</p>\n<p>여기서 우리는 2가지를 알 수 있다.</p>\n<ol>\n<li>훅이 HooksDispatcherOnUpdate(update 훅)으로 교체되었다는 점</li>\n<li>numberOfReRenders 카운팅하고 있다는 점</li>\n</ol>\n<p>2가지를 알아보자.</p>\n<h4>HooksDispatcherOnUpdate</h4>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">HooksDispatcherOnUpdate</span>: <span class=\"hljs-title class_\">Dispatcher</span> = {\n  readContext,\n\n  <span class=\"hljs-attr\">useCallback</span>: updateCallback,\n  <span class=\"hljs-attr\">useContext</span>: readContext,\n  <span class=\"hljs-attr\">useEffect</span>: updateEffect,\n  <span class=\"hljs-attr\">useImperativeHandle</span>: updateImperativeHandle,\n  <span class=\"hljs-attr\">useLayoutEffect</span>: updateLayoutEffect,\n  <span class=\"hljs-attr\">useMemo</span>: updateMemo,\n  <span class=\"hljs-attr\">useReducer</span>: updateReducer,\n  <span class=\"hljs-attr\">useRef</span>: updateRef,\n  <span class=\"hljs-attr\">useState</span>: updateState,\n  <span class=\"hljs-attr\">useDebugValue</span>: updateDebugValue,\n  <span class=\"hljs-attr\">useResponder</span>: createResponderListener,\n  <span class=\"hljs-attr\">useDeferredValue</span>: updateDeferredValue,\n  <span class=\"hljs-attr\">useTransition</span>: updateTransition,\n};\n</code></pre>\n<p>mount와 다르게 useState는 mountState가 아닌 <strong>updateState가 할당되어 있다.</strong><br>\n이는 컴포넌트 재호출할 때 setter함수는 이제 updateState 함수를 호출하게 된다라는 의미이다.</p>\n<h4>numberOfReRenders</h4>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">function</span> dispatchAction&lt;S, A&gt;(\n  <span class=\"hljs-attr\">fiber</span>: <span class=\"hljs-title class_\">Fiber</span>,\n  <span class=\"hljs-attr\">queue</span>: <span class=\"hljs-title class_\">UpdateQueue</span>&lt;S, A&gt;,\n  <span class=\"hljs-attr\">action</span>: A,\n) {\n  <span class=\"hljs-title function_\">invariant</span>(\n    numberOfReRenders &lt; <span class=\"hljs-variable constant_\">RE_RENDER_LIMIT</span>,\n    <span class=\"hljs-string\">&#x27;Too many re-renders. React limits the number of renders to prevent &#x27;</span> +\n      <span class=\"hljs-string\">&#x27;an infinite loop.&#x27;</span>,\n  );\n</code></pre>\n<p>numberOfReRenders는 dispatchAction에서 한계 숫자를 넘으면 오류가 발생하도록 체크하고 있다.<br>\n오류 메세지는 우리가 상태업데이트가 무한루프에 빠졌을 때 가끔 보게 되는 메세지다.<br>\n참고로 RE_RENDER_LIMIT 한계는 25로 정의되어있다.(<code>const RE_RENDER_LIMIT = 25;</code>)</p>\n<h2>마치며</h2>\n<p>이번 포스팅에서는 setState 내부 코드와 여러번 호출하면 어떤일이 발생하는지에 대해 알아보았다.<br>\n다음 시간에는 스케쥴에 work를 등록하는 과정에 대해 알아보자.</p>\n"},{"attributes":{"title":"[시리즈] 리액트 원리 파헤치기 05 - useState의 state는 어떻게 구현되어 있을까?","summary":"리액트 파헤치기 시리즈 - useState 2","tag":["리액트 파헤치기 시리즈","REACT","useState"],"idx":5},"htmlBody":"<p>바로 이전 포스팅에서 useState가 정의된 곳에 대해 코드레벨에서 살펴보았다.<br>\n그곳은 컴포넌트 상태에 따라 mountState 또는 updateState였다.<br>\n그 중 mountState를 까보자.<br>\n<img src=\"../../static/img/series/react/HooksDispatcherOnMount.png\" alt=\"HooksDispatcherOnMount\"></p>\n<h2>mountState 함수</h2>\n<p><img src=\"../../static/img/series/react/mountState.png\" alt=\"mountState\"></p>\n<ul>\n<li>\n<p><code>const hook = mountStateImpl(initialState)</code>\nmountStateImpl 함수를 통해 hook을 전달받고 있다.</p>\n<p><img src=\"../../static/img/series/react/mountStateImpl.png\" alt=\"mountStateImpl\"></p>\n<ul>\n<li>\n<p><code>const hook = mountWorkInProgressHook();</code>를 호출하고 있다.\nmountWorkInProgressHook 함수는 hook 객체가 정의되어있다.</p>\n<p><img src=\"../../static/img/series/react/mountWorkInProgressHook.png\" alt=\"mountWorkInProgressHook\"></p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">hook</span>: <span class=\"hljs-title class_\">Hook</span>  = {\n    <span class=\"hljs-attr\">memoizedState</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">baseState</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">baseQueue</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">queue</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">next</span>: <span class=\"hljs-literal\">null</span>\n}\n</code></pre>\n<ul>\n<li>memoizedState 프로퍼티는 마지막으로 기억하고있는 계산된 state값이다.</li>\n<li>next 프로퍼티는 다음 hook을 가리키는 포인터 역할이다.</li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">if</span> (workInProgressHook === <span class=\"hljs-literal\">null</span>) {\n  currentlyRenderingFiber.<span class=\"hljs-property\">memoizedState</span> = workInProgressHook = hook;\n} <span class=\"hljs-keyword\">else</span> {\n  workInProgressHook = workInProgressHook.<span class=\"hljs-property\">next</span> = hook;\n}\n</code></pre>\n<ul>\n<li>\n<p>조건절 <code>workInProgressHook === null</code></p>\n<ul>\n<li>true : 작업중인 훅이 없다면 currentlyRenderingFiber.memoizedState와 workInProgressHook에 hook을 주입하고</li>\n<li>false : 작업중인 훅이 존재한다면\nworkInProgressHook.next에 hook정보를 주입하고, workInProgressHook은 next에 hook이 주입된 hook이 할당되게된다. (<strong>바로 이 부분으로 인해 링크드 리스트 구조로 next를 통해 hook끼리 연결되게 된다.</strong>)</li>\n</ul>\n</li>\n<li>\n<p>workInProgressHook을 리턴한다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>다시 mountStateImpl을 보자.\n<img src=\"../../static/img/series/react/mountStateImpl.png\" alt=\"mountStateImpl\"></p>\n<ul>\n<li>\n<p>인자로 받은 initialState를 hook.memoizedState와 hook.baseState에 저장하고 있다.</p>\n</li>\n<li>\n<p>이때 initialState가 함수이면 함수를 호출한 결과값을 저장한다. (<strong>바로 우리가 useState인자로 함수를 넘기면 발생하게 되는 코드이며, 게으른 초기화가 여기서 이루어진다</strong>)</p>\n</li>\n<li>\n<p>queue 객체 : 상태를 업데이트할 때 필요한 정보들을 담고 있는 객체이며, dispatch가 상태를 업데이트하는 함수이다. (다음 포스팅에 자세히 설명하겠다)</p>\n</li>\n<li>\n<p>hook을 리턴한고 함수를 종료한다.</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>mountState 나머지 부분을 보자.\n<img src=\"../../static/img/series/react/mountState02.png\" alt=\"mountState02\"></p>\n<ul>\n<li>\n<p>dispatch는 상태 업데이트 함수이다.</p>\n<ul>\n<li>dispatch는 dispatchSetState함수를 bind하고있는데, 이때 인자들은 currentlyRenderingFiber(현재 fiber)와 queue이다.</li>\n</ul>\n</li>\n<li>\n<p><code>return [hook.memoizedState, dispatch]</code></p>\n<ul>\n<li>즉, useState 함수 리턴값 배열의 첫번째 원소는 hook.memoizedState가 들어가게되고(<strong>state</strong>), 두번째 원소는 dispatch가 상태 업데이트 함수(<strong>setState</strong>)로 들어가게된다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>정리</h2>\n<p>우리가 useState 호출을 통해 리턴받는 배열은 바로 <code>return [hook.memoizedState, dispatch]</code> 이 부분이며, 첫번째 원소로는 기억하고있는 상태값인 <strong>hook.memoizedState</strong>이고 두번째 원소로는 상태 업데이트 함수인 <strong>dispatch</strong>이다.</p>\n<h2>마치며</h2>\n<p>이번 포스팅에서는 useState의 state가 어떻게 구현되어있는지 살펴보았고 setState에 대해서도 간략히 살펴보았다.<br>\n다음 포스팅에서 setState에 대해 자세히 알아보자.</p>\n"},{"attributes":{"title":"[시리즈] 리액트 원리 파헤치기 04 - useState가 정의된 곳","summary":"리액트 파헤치기 시리즈 - useState 1","tag":["리액트 파헤치기 시리즈","REACT","useState"],"idx":4},"htmlBody":"<p>본격적으로 useState를 코드레벨에서 까보면서 useState는 어떻게 구현되어있는지, 그리고 reconciler가 무슨 역할을 하는지에 대해 알아보자.<br>\n&quot;<strong>useState 정의된 위치 -&gt; useState의 state -&gt; useState의 setState</strong>&quot; 순서로 포스팅을 작성하려고 한다.<br>\n그럼 이번 포스팅에는 useState가 정의된 위치가 어디인지 파헤쳐보자.</p>\n<p>우리가 분석할 패키지는 react, shared, react-reconciler 패키지이다.<br>\n각 패키지에 대해 간단히 소개하자면</p>\n<ol>\n<li><strong>react 패키지</strong> : react 패키지는 코어 패키지이며, react element가 정의되어있고 그 외는 shared 패키지를 통해 주입받고있다.</li>\n<li><strong>react-reconciler</strong> : react-reconciler는 react element를 VDOM에 반영하기 위해 fiber node로 확장하는 패키지이다.</li>\n<li><strong>shared 패키지</strong> : shared 패키지는 패키지들끼리 의존성을 갖는 부분에 대해 정의되어있는 패키지이며, 통로 역할을 한다.</li>\n</ol>\n<p>그럼 react 패키지 진입점부터 확인해보자.</p>\n<h2>react/index.js</h2>\n<p>이 파일은 단순히 <code>react/src/ReactClient.js</code>에서 받아온 정보들을 export하고 있다.</p>\n<h2>react/src/ReactClient.js</h2>\n<p><img src=\"../../static/img/series/react/ReactClient.png\" alt=\"ReactClient\"><br>\n<img src=\"../../static/img/series/react/ReactClient02.png\" alt=\"ReactClient02\"></p>\n<p>ReactClient에서 ReactHooks의 useState를 import하여 export하고 있다.</p>\n<h2>react/src/ReactHooks.js</h2>\n<p><img src=\"../../static/img/series/react/ReactHooks.png\" alt=\"ReactHooks\"></p>\n<p>여기에 useState가 정의되어 export되고 있고,<br>\nresolveDispatcher함수에서 꺼내오는걸 확인할 수 있다.</p>\n<ul>\n<li>resolveDispatcher 함수\n<img src=\"../../static/img/series/react/ReactHooks02.png\" alt=\"resolveDispatcher\"><br>\nReactCurrentDispatcher.current에서 꺼내오고 리턴한다.</li>\n</ul>\n<h2>react/src/ReactCurrentDispatcher.js</h2>\n<p><img src=\"../../static/img/series/react/ReactCurrentDispatcher.png\" alt=\"ReactCurrentDispatcher\"><br>\nReactCurrentDispatcher.current에는 null이 할당되어있다.</p>\n<p>여기까지 확인해보면 react 패키지에는 hook에 대한 코드가 없는 것으로 확인할 수 있다.<br>\n(밑에서 확인해보겠지만, hook 정보는 reconciler가 관리하고 있다.)</p>\n<h2>react/src/ReactSharedInternalsClient.js</h2>\n<p><img src=\"../../static/img/series/react/ReactSharedInternalsClient.png\" alt=\"ReactSharedInternalsClient\"><br>\n여기서 ReactCurrentDispatcher를 import하여\nReactSharedInternals 객체의 프로퍼티로 할당하고 있다.<br>\n즉, reconciler로 부터 hook 정보를 ReactSharedInternals를 통해 주입받는 구조인 것이다.<br>\n따라서 shared 패키지의 ReactSharedInternals를 확인해보자.</p>\n<h2>shared/ReactSharedInternals.js</h2>\n<p><img src=\"../../static/img/series/react/ReactSharedInternals.png\" alt=\"ReactSharedInternals\"><br>\n여기에 정보를 주입하면 react/src/ReactSharedInternals.js 여기로 전달이 되는 구조다.<br>\n전달되는 형태에 대해서는 추후에 자세히 알아볼것이니 지금은 이러한 구조라는 것에 대해 기억하자.</p>\n<p>이제 실질적으로 hook정보를 주입해주는 reconciler 패키지를 뜯어보자.</p>\n<h2>react-reconciler/src/ReactFiberHooks.js</h2>\n<ul>\n<li>\n<p>shared 패키지의 ReactSharedInternals를 import한다.\n<img src=\"../../static/img/series/react/ReactFiberHooks01.png\" alt=\"ReactFiberHooks01\"></p>\n</li>\n<li>\n<p>ReactSharedInternals에서 ReactCurrentDispatcher를 꺼내온다.<br>\n<img src=\"../../static/img/series/react/ReactFiberHooks02.png\" alt=\"ReactFiberHooks02\"></p>\n</li>\n</ul>\n<h3>renderWithHooks 함수</h3>\n<ul>\n<li>\n<p>ReactCurrentDispatcher.current는 renderWithHooks 함수에서 할당해주고 있다.\n<img src=\"../../static/img/series/react/renderWithhooks01.png\" alt=\"renderWithhooks01\"></p>\n</li>\n<li>\n<p>조건절 <code>current === null || current.memoizedState === null</code>\n현재 current 트리가 없다는 뜻이며, 컴포넌트가 Mount 상태라는 것이다.</p>\n<ul>\n<li>\n<p>true이면, 마운트 hook정보인 HooksDispatcherOnMount를 주입한다.</p>\n</li>\n<li>\n<p>false이면, 업데이트 상태라는 것이므로 HooksDispatcherOnUpdate를 주입한다.</p>\n</li>\n<li>\n<p>HooksDispatcherOnMount와 HooksDispatcherOnUpdate는 hook 정보들이 담겨있는 객체이다.<br>\n<img src=\"../../static/img/series/react/HooksDispatcherOnMount.png\" alt=\"HooksDispatcherOnMount\"><br>\n<img src=\"../../static/img/series/react/HooksDispatcherOnUpdate.png\" alt=\"HooksDispatcherOnUpdate\"><br>\n<strong>여기서 useState가 mount상태면 mountState, 업데이트상태면 updateState가 할당되는 것을 확인할 수 있다.</strong></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2>정리</h2>\n<p>정리하자면 useState가 정의된 곳은 react-reconciler의 ReactFiberHooks에서 mountState, updateState 함수이며, useState의 실체는 mountState 또는 updateState인 것이다.</p>\n<h2>마치며</h2>\n<p>이제 정의된 위치에 대해 살펴보았으니, mountState 함수를 까보면서 useState 내부 코드에 대해 알아보자.</p>\n"},{"attributes":{"title":"[시리즈] 리액트 원리 파헤치기 03 - VDOM과 reconciler","summary":"리액트 파헤치기 시리즈 - VDOM과 reconciler","tag":["리액트 파헤치기 시리즈","REACT"],"idx":3},"htmlBody":"<p>virtual DOM이라고 하는 VDOM과 reconciler에 대해 알아보자.</p>\n<h2>VDOM은 리액트의 렌더링 컨셉이다.</h2>\n<p>UI 정보를 가진 가상 DOM과 실제 DOM을 비교하여(재조정) 업데이트된 부분만 일괄로 브라우저에 반영한다라는 컨셉이다.<br>\n왜 가상에서 하냐면 실제 DOM을 조작하면서 paint하면 가상으로 하는것보다 훨씬 더 비용이 들기 때문이다.<br>\n따라서 리액트는 가상 DOM과 렌더링 과정 최적화(재조정 reconciliation)를 통해 렌더링을 지원하는 라이브러리이다.</p>\n<p>그렇다면 리액트의 렌더링 방식은 어떤 설계방식(아키텍쳐)로 이루어져있을까?<br>\n그건 바로 리액트 파이버이다.</p>\n<h2>VDOM의 구현</h2>\n<p>리액트 파이버아키텍쳐에서 VDOM은 FiberNode 생성자 함수로 생성한 객체들의 집합으로 이루어진 트리 구조이다.<br>\n이 파이버 트리는 애플리케이션의 구조와 상태를 나타내며 current트리와 workInProgress 트리 2개가 존재한다.</p>\n<ol>\n<li><strong>current 트리</strong></li>\n</ol>\n<ul>\n<li>현재 UI 렌더링 정보가 담긴 파이버 트리</li>\n</ul>\n<ol start=\"2\">\n<li><strong>workInProgress 트리</strong></li>\n</ol>\n<ul>\n<li>작업중인 상태를 나타내는 트리</li>\n</ul>\n<p>왜 2개가 존재하냐면 더블 버퍼링 구조로 설계되어 있기때문에 원본 트리와 작업중 트리를 가지고 있으며,<br>\n렌더링 순서를 유연하게 조작하기 위해서는 원본이 필요하기 때문이다.\n즉, 업데이트가 발생하면 current tree를 복제하여 workInProgress tree가 생성되고<br>\n이 workInProgress tree에 변경사항을 업데이트하고 재조정 과정을 거쳐 render phase가 끝나고 commit phase에서 current tree로 교체된다.</p>\n<h2>reconciler</h2>\n<p>reconciler는 업데이트를 감지하여 workInProgress 트리를 만들고  current트리와 workInProgress 트리를 비교하여 실제 DOM에 적용할 업데이트사항을 결정하는 역할을 한다.</p>\n<h2>라이프사이클</h2>\n<p>리액트에서 라이프사이클 단계는 render phase단계와 commit phase단계로 이루어져있다.</p>\n<ol>\n<li><strong>render phase</strong></li>\n</ol>\n<ul>\n<li>VDOM을 재조정(reconciliation)하는 단계이다.</li>\n<li>이 과정은 비동기로 실행될 수 있다.(이전 stack아키텍처는 이부분이 동기적으로 발생되었었음)</li>\n</ul>\n<ol start=\"2\">\n<li><strong>commit phase</strong></li>\n</ol>\n<ul>\n<li>재조정한 VDOM을 실제 DOM에 일괄 반영하고 라이프사이클 메소드 또는 훅을 실행하는 단계이다.</li>\n<li>이 과정은 동기적으로 실행된다.</li>\n</ul>\n<h2>마치며</h2>\n<p>이번에는 VDOM과 reconciler가 무엇인지에 대해 간략히 알아보았다.<br>\n복잡하게 생각할 필요없이 결국 리액트는 VDOM과 reconciler라는 컨셉을 통해 렌더링 과정을 최적화하는 라이브러리라는 것을 기억하자.<br>\n다음은 useState를 코드 레벨에서 까보면서 reconciler가 어떤 역할을 하는지 자세히 알아보자.</p>\n"},{"attributes":{"title":"[시리즈] 리액트 원리 파헤치기 02 - react element","summary":"리액트 파헤치기 시리즈 - react element","tag":["리액트 파헤치기 시리즈","REACT"],"idx":2},"htmlBody":"<p>fiber node 객체에 대해 살펴보기전에 react element가 무엇인지 정확히 알고 넘어갈 필요가 있다.<br>\nreact element가 무엇인지에 대해 살펴보자</p>\n<h2>react element란?</h2>\n<p>react element는 컴포넌트 관련 정보를 갖고 있는 객체이다. type, key, props, ref 등의 프로퍼티를 소유하고 있다.<br>\nreact element 종류로는 DOM elements와 Component elements가 있다.</p>\n<p>우리가 리액트 컴포넌트를 작성할때 JSX문법으로 작성하면 그것을 트랜스파일링하여 react element 형태를 리턴받게 된다.<br>\n이 과정을 좀더 자세하게 설명하자면 다음과 같다.</p>\n<pre class=\"hljs\"><code>컴포넌트를 호출 -&gt; 리턴한 <span class=\"hljs-variable constant_\">DOM</span> elements (<span class=\"hljs-variable constant_\">JSX</span> 문법) -&gt; 트랜스파일링 -&gt; react.<span class=\"hljs-title function_\">createElement</span>()를 호출 -&gt; react element를 리턴받음\n</code></pre>\n<p>컴포넌트를 호출했을때 Component elements를 리턴받으면 DOM elements를 리턴할때까지 계속해서 순회하여 호출하게 된다. 결국 DOM elements로 구성되어있는 element tree가 완성된다.</p>\n<h2>react element의 종류</h2>\n<p>종류는 DOM elements, Component elements 2가지 종류가 있다.<br>\n<code>(type: string | ReactClass, props: object)</code><br>\n이때 type이 string이면 DOM elements이며, ReactClass이면 Component elements이다.</p>\n<ol>\n<li>DOM elements</li>\n</ol>\n<ul>\n<li>type: string</li>\n<li>props: html태그의 attribute</li>\n</ul>\n<pre class=\"hljs\"><code>&lt;button className=<span class=\"hljs-string\">&quot;btn-red&quot;</span>&gt;\n    confirm\n&lt;/button&gt;\n\n<span class=\"hljs-comment\">// 트랜스파일링 결과</span>\n{\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;button&#x27;</span>,\n    <span class=\"hljs-attr\">props</span>: {\n      <span class=\"hljs-attr\">className</span>: <span class=\"hljs-string\">&#x27;btn-red&#x27;</span>,\n      <span class=\"hljs-attr\">children</span>: <span class=\"hljs-string\">&#x27;confirm&#x27;</span>\n    }\n}\n</code></pre>\n<ol start=\"2\">\n<li>Component elements</li>\n</ol>\n<ul>\n<li>type: ReactClass</li>\n<li>props: DOM 렌더링에 필요한 정보들</li>\n</ul>\n<pre class=\"hljs\"><code>&lt;<span class=\"hljs-title class_\">Button</span> color=<span class=\"hljs-string\">&quot;red&quot;</span>&gt;confirm&lt;/<span class=\"hljs-title class_\">Button</span>&gt;\n\n<span class=\"hljs-comment\">// 트랜스파일링 결과</span>\n{\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">Button</span>,\n    <span class=\"hljs-attr\">props</span>: {\n        <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&#x27;red&#x27;</span>,\n        <span class=\"hljs-attr\">children</span>: <span class=\"hljs-string\">&#x27;confirm&#x27;</span>\n    }\n}\n</code></pre>\n<p>Component elements는 DOM elements를 캡슐화한 것이다.<br>\n해당 컴포넌트를 호출하면 DOM elements를 결국 return 하게 된다.</p>\n<pre class=\"hljs\"><code>&lt;<span class=\"hljs-title class_\">Button</span> color=<span class=\"hljs-string\">&quot;red&quot;</span>&gt;confirm&lt;/<span class=\"hljs-title class_\">Button</span>&gt;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Button</span>(<span class=\"hljs-params\">props</span>) {\n  <span class=\"hljs-keyword\">return</span> (\n\t&lt;button className={props.color}&gt;\n\t\tconfirm\n\t&lt;/button&gt;\n  )\n}\n</code></pre>\n<h2>정리</h2>\n<p>즉 Component elements로 개발자가 직접 DOM 트리에 전달할 정보를 정의할 수 있고<br>\n각각의 elements들이 elements tree 구조로 이루어 DOM 트리에 전달할 정보를 가지고 있게 되는 자바스크립트 객체인 것이다.</p>\n<h2>마치며</h2>\n<p>사실 react element는 fiber node로 확장되어 VDOM에 반영되게 된다.<br>\n이는 앞으로 자세하게 알아볼 것이니 react element가 무엇인지에 대해서만 기억하자</p>\n"},{"attributes":{"title":"[시리즈] 리액트 원리 파헤치기 01 - Intro","summary":"리액트 파헤치기 시리즈 - 사전지식","tag":["리액트 파헤치기 시리즈","REACT"],"idx":1},"htmlBody":"<p>리액트 원리를 깊게 파악하고 싶어서 <strong>&quot;리액트 원리 파헤치기&quot;</strong> 시리즈를 작성하려고 한다.<br>\n이 시리즈는 리액트 아키텍쳐와 리액트 패키지가 어떻게 구성되어있는지, 동작 원리는 무엇인지 파헤쳐보는 시리즈이다.<br>\n본격적으로 시리즈에 들어가기 앞서 리액트 원리를 이해하는데 필요한 배경과 사전지식에 대해 알아보자</p>\n<h2>배경</h2>\n<p>리액트 16버전 이전에는 <strong>Stack Reconciler 아키텍쳐</strong>로 구성되어 있었다.<br>\nstack 자료구조 형태이기 때문에 LIFO 형태로 마지막에 들어간 task를 먼저 렌더링해야만 하는 고정적인 순서가 있었고, 동기적으로 컴포넌트 트리를 업데이트해야만 했다.<br>\n이는 업데이트가 크게 발생하면 브라우저 메인 스레드를 블로킹하므로 마치 UI가 멈춘것처럼 느껴지게 하는 좋지않은 UX를 안겨주었고,\n렌더링 순서도 마음대로 변경하거나 일시중단할 수 없었다.<br>\n특히 복잡한 애플리케이션에서 렌더링 성능에 악영향을 미쳤다.<br>\n따라서 이러한 문제를 해결하기 위해 Fiber 아키텍쳐가 도입되었다.</p>\n<h2>Fiber 아키텍쳐란?</h2>\n<p>리액트 16에 등장한 렌더링 아키텍쳐로, Stack 아키텍쳐의 문제점을 해결하기 위해 등장했다.(물론 본격적으로 파이버 아키텍쳐가 사용되기 시작한 버전은 리액트 18버전 부터(useTransition, usedeferredvalue))<br>\n메인 스레드가 블로킹되는 것을 방지하고 비동기적으로 업데이트가 발생하므로 렌더링 task를 일시중단하거나 재개할 수 있으며, 또한 우선순위를 부여하여 우선순위 기반의 스케줄링을 할 수 있다.<br>\n메인 스레드가 블로킹되지 않기 때문에 이전의 Stack 아키텍쳐보다 UX가 향상되었다.</p>\n<h2>알아두어야할 사전지식</h2>\n<p>여기까지 리액트 렌더링 아키텍쳐의 배경과 개념에 대해 간략하게 알아보았다.<br>\n이제 알아두어야할 사전지식들에 대해서 설명하겠다.<br>\n설명할 사전지식들의 목차는 다음과 같다.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-number\">1.</span> 리액트에서의 렌더링 개념\n<span class=\"hljs-number\">2.</span> react element란?\n<span class=\"hljs-number\">3.</span> fiber 노드란?\n</code></pre>\n<p>각각에 대해 알아보자</p>\n<h3>1. 리액트에서의 렌더링 개념</h3>\n<p>리액트에서 렌더링이라고 부르는 개념과 우리가 흔히 알고있는 렌더링 개념은 조금 차이가 있다.<br>\n리액트에서의 렌더링은 컴포넌트를 호출하고 VDOM 재조정 작업까지를 렌더링이라고 하며, 브라우저에 반영되는 것은 이후 commit phase에서 진행한다.<br>\n정리하자면 우리가 알고있는 렌더링은 브라우저에 반영까지인데, 리액트에서 렌더링은 렌더링 재조정자가 진행하는 과정까지를 말한다. 헷갈리지않게 숙지하자.</p>\n<h3>2. react element란?</h3>\n<p>컴포넌트가 리턴한 JSX를 트랜스파일링하여 결국 <code>react.createElement()</code>를 호출하게된다.(요즘은 jsxRuntime) 이때 리턴한 내용을 <strong>react element</strong>라고 한다.<br>\nreact element란 DOM에 적용될 내용이 담긴(컴포넌트 정보들) 객체인데 type, key, props, ref 프로퍼티로 구성되어있다.</p>\n<h3>3. fiber 노드란?</h3>\n<p>react element를 확장한 것으로 VDOM의 노드 객체를 말한다.<br>\nreact element에서 state, 라이프사이클, hook이 추가된 노드이다.(VDOM은 DOM에 반영될 정보가 담겨있다)</p>\n<h2>마치며</h2>\n<p>여기까지 리액트 원리 파헤치기 시리즈에 들어가기 앞서 사전지식들에 대해 작성해보았다.<br>\n다음은 react element가 무엇인지 파헤쳐보자.</p>\n"}]}